# 运单创建后字段值生成机制说明

## 🎯 **字段值生成机制**

根据`logistics_partner_costs`表的字段结构，运单创建后各字段的值生成机制如下：

## 📊 **字段值生成详细说明**

### 1. 状态字段（初始值）

#### `invoice_status` - 开票状态
- **初始值**: `'Uninvoiced'` (未开票)
- **生成时机**: 运单创建时自动设置
- **状态流转**: `Uninvoiced` → `Processing` → `Invoiced`

```sql
-- 运单创建时的默认值
INSERT INTO logistics_partner_costs (
    logistics_record_id,
    partner_id,
    level,
    payable_amount,
    invoice_status,  -- 默认值：'Uninvoiced'
    payment_status   -- 默认值：'Unpaid'
) VALUES (...);
```

#### `payment_status` - 付款状态
- **初始值**: `'Unpaid'` (未付款)
- **生成时机**: 运单创建时自动设置
- **状态流转**: `Unpaid` → `Processing` → `Paid`

### 2. 时间戳字段（事件驱动）

#### `invoice_applied_at` - 开票申请时间
- **初始值**: `NULL`
- **生成时机**: 创建开票申请时
- **生成方式**: 系统自动设置当前时间

```sql
-- 创建开票申请时
UPDATE logistics_partner_costs 
SET 
    invoice_status = 'Processing',
    invoice_request_id = [新生成的UUID],
    invoice_applied_at = NOW()  -- 自动生成当前时间
WHERE logistics_record_id = [运单ID];
```

#### `invoice_completed_at` - 开票完成时间
- **初始值**: `NULL`
- **生成时机**: 开票完成时
- **生成方式**: 系统自动设置当前时间

```sql
-- 完成开票时
UPDATE logistics_partner_costs 
SET 
    invoice_status = 'Invoiced',
    invoice_number = [发票号码],
    invoice_completed_at = NOW()  -- 自动生成当前时间
WHERE invoice_request_id = [申请单ID];
```

#### `payment_applied_at` - 付款申请时间
- **初始值**: `NULL`
- **生成时机**: 创建付款申请时
- **生成方式**: 系统自动设置当前时间

#### `payment_completed_at` - 付款完成时间
- **初始值**: `NULL`
- **生成时机**: 付款完成时
- **生成方式**: 系统自动设置当前时间

### 3. 关联ID字段（事件驱动）

#### `invoice_request_id` - 关联的开票申请ID
- **初始值**: `NULL`
- **生成时机**: 创建开票申请时
- **生成方式**: 系统自动生成UUID

```sql
-- 创建开票申请时生成
INSERT INTO invoice_requests (id, ...) VALUES (gen_random_uuid(), ...);

-- 更新运单关联
UPDATE logistics_partner_costs 
SET invoice_request_id = [新生成的UUID]
WHERE logistics_record_id = [运单ID];
```

#### `payment_request_id` - 关联的付款申请ID
- **初始值**: `NULL`
- **生成时机**: 创建付款申请时
- **生成方式**: 系统自动生成UUID

### 4. 业务字段（用户输入或系统生成）

#### `invoice_number` - 发票号码
- **初始值**: `NULL`
- **生成时机**: 开票完成时
- **生成方式**: 
  - 系统自动生成（按规则）
  - 用户手动输入
  - 外部系统传入

```sql
-- 完成开票时设置发票号码
UPDATE logistics_partner_costs 
SET invoice_number = 'INV-2025-001'  -- 系统生成或用户输入
WHERE invoice_request_id = [申请单ID];
```

#### `payment_reference` - 付款参考号
- **初始值**: `NULL`
- **生成时机**: 付款完成时
- **生成方式**:
  - 银行交易号
  - 第三方支付平台交易号
  - 用户自定义参考号

## 🔄 **完整生命周期示例**

### 阶段1：运单创建
```sql
-- 运单创建后的初始状态
logistics_partner_costs:
├── invoice_status: 'Uninvoiced'
├── payment_status: 'Unpaid'
├── invoice_applied_at: NULL
├── invoice_completed_at: NULL
├── payment_applied_at: NULL
├── payment_completed_at: NULL
├── invoice_request_id: NULL
├── invoice_number: NULL
├── payment_request_id: NULL
└── payment_reference: NULL
```

### 阶段2：创建开票申请
```sql
-- 创建开票申请后的状态
logistics_partner_costs:
├── invoice_status: 'Processing'  -- 状态变更
├── payment_status: 'Unpaid'      -- 保持不变
├── invoice_applied_at: '2025-01-16 10:30:00'  -- 自动生成
├── invoice_completed_at: NULL
├── payment_applied_at: NULL
├── payment_completed_at: NULL
├── invoice_request_id: 'uuid-1234-5678-9abc'  -- 自动生成
├── invoice_number: NULL
├── payment_request_id: NULL
└── payment_reference: NULL
```

### 阶段3：完成开票
```sql
-- 完成开票后的状态
logistics_partner_costs:
├── invoice_status: 'Invoiced'    -- 状态变更
├── payment_status: 'Unpaid'      -- 保持不变
├── invoice_applied_at: '2025-01-16 10:30:00'  -- 保持不变
├── invoice_completed_at: '2025-01-16 14:20:00'  -- 自动生成
├── payment_applied_at: NULL
├── payment_completed_at: NULL
├── invoice_request_id: 'uuid-1234-5678-9abc'  -- 保持不变
├── invoice_number: 'INV-2025-001'  -- 系统生成或用户输入
├── payment_request_id: NULL
└── payment_reference: NULL
```

## 🛠️ **技术实现机制**

### 1. 数据库触发器
```sql
-- 自动更新时间戳的触发器
CREATE OR REPLACE FUNCTION update_partner_costs_timestamps()
RETURNS TRIGGER AS $$
BEGIN
    -- 开票状态变化时更新时间戳
    IF OLD.invoice_status IS DISTINCT FROM NEW.invoice_status THEN
        IF NEW.invoice_status = 'Processing' AND OLD.invoice_status = 'Uninvoiced' THEN
            NEW.invoice_applied_at = NOW();
        ELSIF NEW.invoice_status = 'Invoiced' AND OLD.invoice_status = 'Processing' THEN
            NEW.invoice_completed_at = NOW();
        END IF;
    END IF;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;
```

### 2. 应用层逻辑
```typescript
// 创建开票申请时的前端逻辑
const createInvoiceRequest = async (recordIds: string[]) => {
  // 1. 创建申请单
  const { data: request } = await supabase.rpc('save_invoice_request', {
    p_record_ids: recordIds
  });
  
  // 2. 系统自动更新运单状态
  // logistics_partner_costs 表的状态会自动更新
};
```

### 3. 状态验证
```sql
-- 检查状态转换的合法性
CREATE OR REPLACE FUNCTION validate_status_transition(
  old_status text,
  new_status text
) RETURNS boolean AS $$
BEGIN
  -- 定义合法的状态转换
  CASE old_status
    WHEN 'Uninvoiced' THEN
      RETURN new_status IN ('Processing');
    WHEN 'Processing' THEN
      RETURN new_status IN ('Invoiced', 'Uninvoiced');
    WHEN 'Invoiced' THEN
      RETURN false;  -- 已开票状态不能转换
    ELSE
      RETURN false;
  END CASE;
END;
$$ LANGUAGE plpgsql;
```

## 📋 **总结**

### 字段值生成规律
1. **初始值**: 状态字段有默认值，时间戳和ID字段为NULL
2. **事件驱动**: 时间戳和ID字段在特定事件发生时生成
3. **系统生成**: UUID和时间戳由系统自动生成
4. **用户输入**: 发票号码和付款参考号可能由用户输入
5. **状态流转**: 状态字段按预定义规则流转

### 关键特点
- ✅ **自动化**: 大部分字段值由系统自动生成
- ✅ **事件驱动**: 字段值更新与业务事件同步
- ✅ **状态一致**: 通过触发器确保数据一致性
- ✅ **可追溯**: 完整的时间戳记录业务流程

这样确保了运单创建后，所有相关字段都能正确生成和更新！🎉
