# 合作链路成本重算验证说明

## 🔍 **问题发现**

在检查合作链路更新功能时，发现了一个重要问题：

### **问题描述：**
合作链路修改函数中调用的成本重算函数参数不匹配，可能导致成本重算失败。

### **具体问题：**
```sql
-- 当前调用方式（错误）
SELECT public.recalculate_costs_for_chain_safe(ARRAY[p_record_id]) INTO v_recalc_result;

-- 实际函数签名
CREATE OR REPLACE FUNCTION public.recalculate_costs_for_chain_safe(
    p_project_id UUID,
    p_chain_id UUID,
    p_only_unpaid BOOLEAN DEFAULT TRUE
)
```

## 🔧 **问题分析**

### **1. 函数参数不匹配**
- **调用方式**：`recalculate_costs_for_chain_safe(ARRAY[p_record_id])`
- **实际签名**：`recalculate_costs_for_chain_safe(project_id, chain_id, only_unpaid)`
- **结果**：函数调用失败，成本重算不会执行

### **2. 影响范围**
- **单个记录修改**：`modify_logistics_record_chain` 函数
- **批量修改**：`batch_modify_logistics_records_chain` 函数
- **结果**：合作链路更新后，合作方成本不会自动重算

## 🛠️ **解决方案**

### **方案1：修复函数调用（推荐）**

#### **修复单个记录修改函数：**
```sql
CREATE OR REPLACE FUNCTION public.modify_logistics_record_chain(
    p_record_id UUID,
    p_chain_name TEXT
) RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_result JSONB;
    v_updated_count INTEGER := 0;
    v_recalc_result JSONB;
    v_project_id UUID;
    v_chain_uuid UUID;
BEGIN
    -- 权限检查...
    
    -- 获取记录的项目ID
    SELECT project_id INTO v_project_id
    FROM public.logistics_records
    WHERE id = p_record_id;

    -- 获取链路ID（通过链路名称查找）
    SELECT id INTO v_chain_uuid
    FROM public.partner_chains
    WHERE chain_name = p_chain_name
    AND project_id = v_project_id;

    -- 更新运单的合作链路
    UPDATE public.logistics_records
    SET 
        chain_id = p_chain_name,
        updated_at = NOW()
    WHERE id = p_record_id;
    
    GET DIAGNOSTICS v_updated_count = ROW_COUNT;

    -- 重新计算合作方成本（使用正确的参数）
    IF v_chain_uuid IS NOT NULL THEN
        SELECT public.recalculate_costs_for_chain_safe(v_project_id, v_chain_uuid, TRUE) INTO v_recalc_result;
    ELSE
        v_recalc_result := jsonb_build_object('success', false, 'message', '未找到对应的链路ID');
    END IF;

    -- 构建返回结果...
END;
$$;
```

#### **修复批量修改函数：**
```sql
CREATE OR REPLACE FUNCTION public.batch_modify_logistics_records_chain(
    p_record_ids UUID[],
    p_chain_name TEXT
) RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_result JSONB;
    v_updated_count INTEGER := 0;
    v_recalc_result JSONB;
    v_project_ids UUID[];
    v_unique_projects INTEGER;
    v_project_id UUID;
    v_chain_uuid UUID;
BEGIN
    -- 权限检查...
    
    -- 获取项目ID
    SELECT array_agg(DISTINCT project_id) INTO v_project_ids
    FROM public.logistics_records
    WHERE id = ANY(p_record_ids);
    
    v_project_id := v_project_ids[1];

    -- 获取链路ID（通过链路名称查找）
    SELECT id INTO v_chain_uuid
    FROM public.partner_chains
    WHERE chain_name = p_chain_name
    AND project_id = v_project_id;

    -- 批量更新运单的合作链路
    UPDATE public.logistics_records
    SET 
        chain_id = p_chain_name,
        updated_at = NOW()
    WHERE id = ANY(p_record_ids);
    
    GET DIAGNOSTICS v_updated_count = ROW_COUNT;

    -- 重新计算合作方成本（使用正确的参数）
    IF v_chain_uuid IS NOT NULL THEN
        SELECT public.recalculate_costs_for_chain_safe(v_project_id, v_chain_uuid, TRUE) INTO v_recalc_result;
    ELSE
        v_recalc_result := jsonb_build_object('success', false, 'message', '未找到对应的链路ID');
    END IF;

    -- 构建返回结果...
END;
$$;
```

### **方案2：创建新的重算函数**

#### **创建接受记录ID数组的重算函数：**
```sql
CREATE OR REPLACE FUNCTION public.recalculate_costs_for_records_safe(
    p_record_ids UUID[]
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
    v_record_id UUID;
    v_updated_count INTEGER := 0;
    v_skipped_count INTEGER := 0;
    v_total_count INTEGER := 0;
    v_project_id UUID;
    v_chain_id UUID;
    v_result JSONB;
BEGIN
    -- 遍历所有记录ID
    FOREACH v_record_id IN ARRAY p_record_ids
    LOOP
        v_total_count := v_total_count + 1;
        
        -- 获取记录的项目ID和链路ID
        SELECT project_id, chain_id INTO v_project_id, v_chain_id
        FROM logistics_records
        WHERE id = v_record_id;
        
        -- 检查记录是否存在
        IF v_project_id IS NULL OR v_chain_id IS NULL THEN
            v_skipped_count := v_skipped_count + 1;
            CONTINUE;
        END IF;
        
        -- 检查是否已付款（跳过已付款的运单）
        IF EXISTS(
            SELECT 1 FROM logistics_records 
            WHERE id = v_record_id 
            AND payment_status = 'Paid'
        ) THEN
            v_skipped_count := v_skipped_count + 1;
            CONTINUE;
        END IF;
        
        -- 重新计算该记录的合作方成本
        -- 这里需要调用具体的重算逻辑
        -- 暂时使用简单的更新逻辑
        UPDATE logistics_partner_costs
        SET 
            payable_amount = (
                SELECT lr.payable_cost * pc.percentage / 100
                FROM logistics_records lr
                JOIN project_partners pp ON pp.project_id = lr.project_id AND pp.chain_id = lr.chain_id
                JOIN partner_costs pc ON pc.partner_id = pp.partner_id
                WHERE lr.id = v_record_id
                AND logistics_partner_costs.partner_id = pp.partner_id
                AND logistics_partner_costs.logistics_record_id = v_record_id
            ),
            updated_at = NOW()
        WHERE logistics_record_id = v_record_id;
        
        GET DIAGNOSTICS v_updated_count = ROW_COUNT;
        
    END LOOP;
    
    -- 构建返回结果
    v_result := jsonb_build_object(
        'success', true,
        'message', '合作方成本重算完成',
        'total_records', v_total_count,
        'updated_records', v_updated_count,
        'skipped_records', v_skipped_count
    );
    
    RETURN v_result;
END;
$$;
```

## 📊 **成本重算验证**

### **1. 验证步骤**

#### **步骤1：检查函数调用**
```sql
-- 检查当前函数调用是否正确
SELECT public.recalculate_costs_for_chain_safe('project_id', 'chain_id', true);
```

#### **步骤2：测试合作链路修改**
```sql
-- 测试单个记录修改
SELECT public.modify_logistics_record_chain('record_id', 'new_chain_name');
```

#### **步骤3：验证成本重算结果**
```sql
-- 检查合作方成本是否更新
SELECT 
    lr.auto_number,
    lr.chain_id,
    lpc.partner_id,
    lpc.payable_amount,
    lpc.updated_at
FROM logistics_records lr
JOIN logistics_partner_costs lpc ON lpc.logistics_record_id = lr.id
WHERE lr.id = 'record_id';
```

### **2. 验证指标**

#### **成功指标：**
- ✅ 函数调用不报错
- ✅ 合作链路更新成功
- ✅ 合作方成本自动重算
- ✅ 重算结果包含统计信息

#### **失败指标：**
- ❌ 函数调用报错
- ❌ 合作链路更新但成本未重算
- ❌ 重算结果为空或失败

## 🎯 **推荐实施步骤**

### **1. 立即修复（推荐方案1）**
```sql
-- 执行修复SQL文件
修复合作链路成本重算_简单方案.sql
```

### **2. 验证修复效果**
- 测试单个记录修改
- 测试批量修改
- 验证成本重算结果

### **3. 监控和测试**
- 监控生产环境中的成本重算
- 定期验证数据一致性
- 建立成本重算的审计日志

## ✅ **修复效果预期**

### **修复前：**
- ❌ 合作链路更新成功
- ❌ 合作方成本不会自动重算
- ❌ 需要手动触发成本重算

### **修复后：**
- ✅ 合作链路更新成功
- ✅ 合作方成本自动重算
- ✅ 跳过已付款运单（安全模式）
- ✅ 返回详细的重算结果

## 🚨 **重要提醒**

1. **数据一致性**：修复前修改的合作链路可能没有重算成本，需要手动检查
2. **测试验证**：修复后必须进行充分测试，确保成本重算正常工作
3. **监控告警**：建议添加成本重算失败的监控告警
4. **回滚准备**：如果修复有问题，需要准备回滚方案

---

**问题发现人**：AI Assistant  
**发现时间**：2025-01-22  
**修复状态**：🔄 待修复  
**验证状态**：⏳ 待验证
