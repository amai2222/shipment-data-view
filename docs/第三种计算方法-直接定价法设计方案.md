# 第三种计算方法：直接定价法设计方案

## 📋 目录
- [功能概述](#功能概述)
- [数据库设计](#数据库设计)
- [计算方法](#计算方法)
- [触发重算机制](#触发重算机制)
- [保护机制](#保护机制)
- [前端界面设计](#前端界面设计)
- [实施步骤](#实施步骤)
- [影响分析](#影响分析)

---

## 功能概述

### 新增计算方法
在现有的**税点法**和**利润法**基础上，新增第三种计算方法：**直接定价法（fixed_price）**

### 计算公式
```
应付金额 = 有效数量 × 单价
```

### 应用场景
- 固定单价合作：与合作方约定固定单价，不依赖基础运价
- 独立定价：不受税点和利润影响，直接按数量计算
- 简化计算：避免复杂的税点或利润计算

---

## 数据库设计

### 1. 修改 `project_partners` 表

#### 新增字段
```sql
ALTER TABLE public.project_partners
ADD COLUMN IF NOT EXISTS unit_price NUMERIC(10,2);  -- 单价（元/单位）

COMMENT ON COLUMN public.project_partners.unit_price IS '直接定价法的单价（元/单位），仅当 calculation_method = fixed_price 时使用';
```

#### 更新约束
```sql
-- 更新 calculation_method 约束，增加 'fixed_price'
ALTER TABLE public.project_partners
DROP CONSTRAINT IF EXISTS check_calculation_method;

ALTER TABLE public.project_partners
ADD CONSTRAINT check_calculation_method 
CHECK (calculation_method IN ('tax', 'profit', 'fixed_price'));
```

### 2. 数据完整性

#### 约束规则
- `calculation_method = 'fixed_price'` 时，`unit_price` 必须 > 0
- `calculation_method != 'fixed_price'` 时，`unit_price` 可以为 NULL
- `effective_quantity` 必须 > 0（由运单触发器自动计算）

---

## 计算方法

### 三种计算方法对比

| 计算方法 | 公式 | 依赖字段 | 适用场景 |
|---------|------|---------|---------|
| **税点法（tax）** | `应付金额 = 基础运价 / (1 - 税点)` | `payable_cost`, `tax_rate` | 含税结算 |
| **利润法（profit）** | `应付金额 = 基础运价 + (利润 × 装货重量)` | `payable_cost`, `profit_rate`, `loading_weight` | 按重量加利润 |
| **直接定价法（fixed_price）** | `应付金额 = 有效数量 × 单价` | `effective_quantity`, `unit_price` | 固定单价 |

### 计算逻辑

#### 直接定价法计算流程
```
1. 获取运单的有效数量（effective_quantity）
   ↓
2. 获取合作方配置的单价（unit_price）
   ↓
3. 计算：应付金额 = 有效数量 × 单价
   ↓
4. 四舍五入到2位小数
```

#### 示例
```
有效数量 = 20 吨
单价 = 10 元/吨
应付金额 = 20 × 10 = 200 元 ✅
```

---

## 触发重算机制

### 自动触发场景

| 修改内容 | 触发原因 | 影响的方法 |
|---------|---------|-----------|
| **有效数量改变** | 直接定价法依赖有效数量 | ✅ fixed_price |
| **基础运价改变** | 税点法和利润法依赖基础运价 | ✅ tax, profit |
| **重量改变** | 可能影响有效数量 | ✅ fixed_price（间接） |
| **链路改变** | 可能改变计费模式，影响有效数量 | ✅ fixed_price（间接） |
| **项目改变** | 可能改变有效数量计算方式 | ✅ fixed_price（间接） |

### 触发器函数

#### 1. `auto_recalc_on_effective_quantity_or_cost_change`
- **触发时机**：`AFTER UPDATE` 运单的 `effective_quantity`, `payable_cost`, `loading_weight`, `unloading_weight`, `chain_id`, `project_id`
- **功能**：自动重算所有合作方成本（支持三种计算方法）
- **保护机制**：
  - ✅ 保护手工修改的合作方成本
  - ✅ 跳过已付款、已开票或已收款的运单

#### 2. `auto_recalc_on_payable_cost_change`
- **触发时机**：`AFTER UPDATE` 运单的 `payable_cost`
- **功能**：基础运价改变时自动重算（支持三种计算方法）
- **保护机制**：
  - ✅ 保护手工修改的合作方成本
  - ✅ 跳过已付款、已开票或已收款的运单

#### 3. `batch_recalculate_partner_costs`
- **触发方式**：手动调用（RPC）
- **功能**：批量重算指定运单的合作方成本（支持三种计算方法）
- **保护机制**：
  - ✅ 保护手工修改的合作方成本
  - ✅ 跳过已付款、已开票或已收款的运单

---

## 保护机制

### 三重保护

#### 1. 状态保护（运单级）
**检查条件**：
```sql
-- 跳过已付款、已开票或已收款的运单
IF NEW.payment_status != 'Unpaid' 
   OR (NEW.invoice_status IS NOT NULL AND NEW.invoice_status != 'Uninvoiced')
   OR (NEW.receipt_status IS NOT NULL AND NEW.receipt_status = 'Received') THEN
    -- 跳过自动重算
    RETURN NEW;
END IF;
```

**保护对象**：
- ✅ 已付款运单（`payment_status != 'Unpaid'`）
- ✅ 已开票运单（`invoice_status != 'Uninvoiced'`）
- ✅ 已收款运单（`receipt_status = 'Received'`）

**保护级别**：**运单级**（整条运单的所有合作方成本都不重算）

#### 2. 手工修改保护（成本记录级）
**检查条件**：
```sql
-- 保存所有手工修改的记录
SELECT json_agg(...)
INTO v_manually_modified_costs
FROM logistics_partner_costs
WHERE logistics_record_id = NEW.id
AND is_manually_modified = true;

-- 检查该合作方是否被手工修改过
IF EXISTS (
    SELECT 1 FROM jsonb_array_elements(v_manually_modified_costs) AS elem
    WHERE (elem->>'partner_id')::UUID = v_project_partners.partner_id
    AND (elem->>'level')::INTEGER = v_project_partners.level
) THEN
    -- 跳过重算，保留原值
    CONTINUE;
END IF;
```

**保护对象**：
- ✅ 手工修改的合作方成本（`is_manually_modified = true`）

**保护级别**：**成本记录级**（只保护特定合作方的成本）

#### 3. 独立计算保护（层级级）
**计算逻辑**：
```sql
-- 每个level都独立从payable_cost计算（不级联）
v_base_amount := NEW.payable_cost;  -- 所有level都从这个基础计算

-- 对于直接定价法，不依赖payable_cost
IF v_project_partners.calculation_method = 'fixed_price' THEN
    v_payable_amount := v_effective_quantity * v_project_partners.unit_price;
END IF;
```

**保护对象**：
- ✅ 每个层级独立计算，互不影响
- ✅ 直接定价法不依赖基础运价，独立计算

---

## 前端界面设计

### 项目设置 - 合作链路配置

#### 新增字段
- **计算方法下拉**：增加"直接定价法"选项
- **单价输入框**：当选择"直接定价法"时显示，单位根据计费模式动态显示（吨/车/立方/件）

#### 界面布局
```
合作方：XXX
层级：1
计算方法：[下拉选择：税点法 | 利润法 | 直接定价法]
税点：% [仅税点法显示]
利润：元/吨 [仅利润法显示]
单价：元/吨 [仅直接定价法显示，单位动态]
```

### 数据验证

#### 前端验证规则
- 选择"直接定价法"时，单价必填且 > 0
- 选择"税点法"时，税点必填且 0 < 税点 < 1
- 选择"利润法"时，利润必填且 >= 0

---

## 实施步骤

### 第一步：数据库迁移

#### 1.1 添加字段和约束
```sql
-- 执行文件：supabase/migrations/20251120_add_fixed_price_calculation_method.sql
-- 内容：
--   - 添加 unit_price 字段
--   - 更新 calculation_method 约束
```

#### 1.2 更新重算函数
```sql
-- 执行文件：supabase/migrations/20251120_update_recalculate_functions_support_fixed_price.sql
-- 内容：
--   - 更新 batch_recalculate_partner_costs（支持 fixed_price）
--   - 更新 auto_recalc_on_payable_cost_change（支持 fixed_price）
```

#### 1.3 添加自动重算触发器
```sql
-- 执行文件：supabase/migrations/20251120_add_trigger_recalc_on_effective_quantity_change.sql
-- 内容：
--   - 创建 auto_recalc_on_effective_quantity_or_cost_change 函数
--   - 创建 trigger_recalc_on_effective_quantity_or_cost_change 触发器
```

### 第二步：前端开发

#### 2.1 更新项目设置界面
- 修改 `src/pages/ProjectSettings/` 相关组件
- 添加"直接定价法"选项
- 添加单价输入框（条件显示）

#### 2.2 更新类型定义
- 修改 `src/types/` 相关类型
- 添加 `unit_price` 字段

#### 2.3 更新显示组件
- 修改对账管理界面
- 修改运单详情界面
- 确保单位显示正确（吨/车/立方/件）

---

## 影响分析

### 场景1：手工修改链路

**操作**：在运单管理中修改运单的链路

**影响**：
- ✅ **直接定价法会重新计算**：如果新链路中合作方使用直接定价法，会根据新链路的配置重新计算
- ✅ **手工修改的保护**：如果该合作方的成本被手工修改过，会保留原值

**示例**：
```
修改前：链路A，合作方X（直接定价法），单价=10元/吨，有效数量=20吨，应付金额=200元
修改后：链路B，合作方Y（直接定价法），单价=12元/吨，有效数量=20吨
自动重算：应付金额 = 20 × 12 = 240 元 ✅
```

### 场景2：手工修改基础运价

**操作**：在运单管理中修改运单的基础运价（`payable_cost`）

**影响**：
- ❌ **直接定价法不受影响**：直接定价法不依赖 `payable_cost`，不会重新计算
- ✅ **税点法和利润法会重新计算**：这两种方法依赖 `payable_cost`

**示例**：
```
修改前：基础运价=1000元，合作方X（直接定价法），单价=10元/吨，有效数量=20吨，应付金额=200元
修改后：基础运价=1200元
直接定价法：应付金额 = 200 元（不变）✅
税点法：应付金额 = 1200 / (1 - 0.1) = 1333.33 元（重新计算）✅
```

### 场景3：手工修改最高级合作方运费

**操作**：在对账管理中手工修改最高级合作方的应付金额

**影响**：
- ✅ **直接定价法会被保护**：如果该合作方使用直接定价法且被手工修改，会保留手工值
- ✅ **自动重算不会覆盖**：即使有效数量改变，手工修改的值也会被保护

**示例**：
```
自动计算：有效数量=20吨，单价=10元/吨，应付金额=200元
手工修改：应付金额=250元（is_manually_modified=true）
有效数量改变：有效数量=25吨
自动重算：应付金额 = 250 元（保留手工值）✅
```

### 场景4：修改有效数量

**操作**：修改运单的装货重量或卸货重量，导致有效数量变化

**影响**：
- ✅ **直接定价法会重新计算**：`应付金额 = 新有效数量 × 单价`
- ✅ **自动触发重算**：已创建触发器 `trigger_recalc_on_effective_quantity_or_cost_change`，修改有效数量、重量、链路或项目时会自动触发重算

**触发条件**：
- 有效数量改变（`effective_quantity`）
- 基础运价改变（`payable_cost`）
- 装货重量改变（`loading_weight`）
- 卸货重量改变（`unloading_weight`）
- 链路改变（`chain_id`）- 可能改变计费模式，影响有效数量
- 项目改变（`project_id`）- 可能改变有效数量计算方式

**示例**：
```
修改前：有效数量 = 20 吨，单价 = 10 元/吨，应付金额 = 200 元
修改后：有效数量 = 25 吨（装货重量从20改为25）
自动重算：应付金额 = 25 × 10 = 250 元 ✅
```

### 场景5：修改计费模式

**操作**：在项目设置中修改链路的计费模式（如从"按重量"改为"按件"）

**影响**：
- ✅ **有效数量会重新计算**：计费模式改变会影响有效数量的计算方式
- ✅ **直接定价法会重新计算**：如果合作方使用直接定价法，会根据新的有效数量重新计算

**示例**：
```
修改前：计费模式=按重量，装货=20吨，卸货=18吨，有效数量=18吨（取最小值）
修改后：计费模式=按件，装货=20件，卸货=18件，有效数量=18件（取最小值）
直接定价法：单价=10元/件，应付金额 = 18 × 10 = 180 元 ✅
```

---

## 总结

### 核心特点
1. ✅ **独立计算**：直接定价法不依赖基础运价，独立计算
2. ✅ **自动重算**：有效数量或基础运价改变时自动触发重算
3. ✅ **三重保护**：状态保护、手工修改保护、独立计算保护
4. ✅ **灵活配置**：支持三种计算方法，可根据合作方灵活选择

### 保护机制总结

| 保护类型 | 检查条件 | 保护对象 | 保护级别 |
|---------|---------|---------|---------|
| **状态保护** | 已付款/已开票/已收款 | 整条运单 | 运单级 |
| **手工修改保护** | `is_manually_modified = true` | 特定合作方成本 | 成本记录级 |
| **独立计算保护** | 每个level独立计算 | 层级间互不影响 | 层级级 |

### 实施建议
1. ✅ **先执行数据库迁移**：确保数据库结构正确
2. ✅ **再更新前端界面**：确保用户可以选择和配置直接定价法
3. ✅ **最后测试验证**：确保所有保护机制正常工作

---

**创建日期**：2025-11-20  
**最后更新**：2025-11-20  
**状态**：✅ 设计方案完成，待实施
