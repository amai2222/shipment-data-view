# 付款申请编辑完整状态保护说明

## 📅 完成日期
2025-10-25

## 🔒 双重状态保护机制

### 保护规则

**运单必须同时满足以下两个条件才能编辑：**

1. ✅ **付款状态** = `Unpaid`（未支付）
2. ✅ **开票状态** = `Uninvoiced` 或 `NULL`（未开票）

### 不可编辑的情况

| 付款状态 | 开票状态 | 能否编辑 | 显示文本 |
|---------|---------|---------|---------|
| Unpaid | Uninvoiced/NULL | ✅ 可以 | 显示编辑按钮 |
| Processing | 任意 | ❌ 不可以 | "已申请支付" |
| Paid | 任意 | ❌ 不可以 | "已完成支付" |
| Unpaid | Processing | ❌ 不可以 | "开票中" |
| Unpaid | Invoiced | ❌ 不可以 | "已开票" |

---

## 🛡️ 三层防护体系（增强版）

### 第1层：前端UI保护

#### 实现位置
`src/pages/PaymentRequest.tsx` - 第133-148行（辅助函数）+ 第623-655行（UI逻辑）

#### 辅助函数

```typescript
// 检查运单是否可编辑（需要同时满足：未支付 且 未开票）
const isRecordEditable = (record: LogisticsRecordWithPartners): boolean => {
  const isPaymentEditable = record.payment_status === 'Unpaid';
  const isInvoiceEditable = !record.invoice_status || record.invoice_status === 'Uninvoiced';
  return isPaymentEditable && isInvoiceEditable;
};

// 获取不可编辑的原因
const getUneditableReason = (record: LogisticsRecordWithPartners): string => {
  if (record.payment_status !== 'Unpaid') {
    return record.payment_status === 'Processing' ? '已申请支付' : '已完成支付';
  }
  if (record.invoice_status && record.invoice_status !== 'Uninvoiced') {
    return record.invoice_status === 'Processing' ? '开票中' : '已开票';
  }
  return '';
};
```

#### UI显示逻辑

```typescript
{isRecordEditable(r) ? (
  // 显示编辑按钮
  <>
    <Button>✏️ 修改运费</Button>
    <Button>🔗 修改链路</Button>
  </>
) : (
  // 显示不可编辑原因
  <span title={`不可编辑：${getUneditableReason(r)}`}>
    {getUneditableReason(r)}
  </span>
)}
```

---

### 第2层：前端逻辑保护

#### 实现位置
`src/pages/PaymentRequest.tsx` - 第378-397行

#### 双重验证逻辑

```typescript
const handleSavePartnerCost = async () => {
  // 1. 查询运单当前状态（包括付款和开票状态）
  const { data: recordData } = await supabase
    .from('logistics_records')
    .select('payment_status, invoice_status')
    .eq('id', editPartnerCostData.recordId)
    .single();
  
  // 2. 验证付款状态
  if (recordData.payment_status !== 'Unpaid') {
    const statusText = recordData.payment_status === 'Processing' 
      ? '已申请支付' 
      : '已完成支付';
    throw new Error(`只有未支付状态的运单才能修改运费。当前付款状态：${statusText}`);
  }
  
  // 3. 验证开票状态
  if (recordData.invoice_status && recordData.invoice_status !== 'Uninvoiced') {
    const statusText = recordData.invoice_status === 'Processing' 
      ? '开票中' 
      : '已开票';
    throw new Error(`只有未开票状态的运单才能修改运费。当前开票状态：${statusText}`);
  }
  
  // 4. 两个状态都通过，继续执行更新
  // ...
};
```

---

### 第3层：后端数据库保护

#### 实现位置
`supabase/migrations/20251025_fix_modify_chain_with_recalculation.sql` - 第74-98行

#### RPC函数双重验证

```sql
CREATE OR REPLACE FUNCTION modify_logistics_record_chain_with_recalc(...)
RETURNS JSON AS $$
DECLARE
    v_payment_status TEXT;
    v_invoice_status TEXT;
BEGIN
    -- 1. 获取运单信息（包含两个状态）
    SELECT payment_status, invoice_status
    INTO v_payment_status, v_invoice_status
    FROM logistics_records
    WHERE id = p_record_id;
    
    -- 2. 验证付款状态
    IF v_payment_status != 'Unpaid' THEN
        RETURN json_build_object(
            'success', false,
            'message', '只有未支付状态的运单才能修改合作链路。当前付款状态：...'
        );
    END IF;
    
    -- 3. 验证开票状态
    IF v_invoice_status IS NOT NULL AND v_invoice_status != 'Uninvoiced' THEN
        RETURN json_build_object(
            'success', false,
            'message', '只有未开票状态的运单才能修改合作链路。当前开票状态：...'
        );
    END IF;
    
    -- 4. 两个状态都通过，继续执行修改
    -- ...
END;
$$;
```

---

## 📊 完整状态流转图

### 正常业务流程

```
1. 创建运单
   ↓
   payment_status = 'Unpaid'
   invoice_status = NULL/'Uninvoiced'
   ✅ 可以修改运费
   ✅ 可以修改链路

2. 生成付款申请
   ↓
   payment_status = 'Processing'
   invoice_status = 仍为 'Uninvoiced'
   ❌ 不能修改（付款状态不符）

3. 审批通过，完成支付
   ↓
   payment_status = 'Paid'
   invoice_status = 仍为 'Uninvoiced'
   ❌ 不能修改（付款状态不符）

4. 生成开票申请
   ↓
   payment_status = 'Paid'
   invoice_status = 'Processing'
   ❌ 不能修改（两个状态都不符）

5. 开票完成
   ↓
   payment_status = 'Paid'
   invoice_status = 'Invoiced'
   ❌ 不能修改（两个状态都不符）
```

### 其他可能的流程

#### 场景1：先开票后付款

```
1. 创建运单 (Unpaid, Uninvoiced) ✅ 可编辑
2. 生成开票申请 (Unpaid, Processing) ❌ 不可编辑（开票状态）
3. 开票完成 (Unpaid, Invoiced) ❌ 不可编辑（开票状态）
4. 生成付款申请 (Processing, Invoiced) ❌ 不可编辑（两个状态都不符）
```

#### 场景2：需要修改已申请的运单

```
方式A：撤销付款申请
1. 撤销付款申请 → payment_status = 'Unpaid'
2. 检查开票状态：
   - 如果 invoice_status = 'Uninvoiced' → ✅ 可以修改
   - 如果 invoice_status = 'Processing/Invoiced' → ❌ 仍不能修改
3. 修改完成
4. 重新生成付款申请

方式B：撤销开票申请
1. 撤销开票申请 → invoice_status = 'Uninvoiced'
2. 检查付款状态：
   - 如果 payment_status = 'Unpaid' → ✅ 可以修改
   - 如果 payment_status = 'Processing/Paid' → ❌ 仍不能修改
3. 修改完成
4. 重新生成开票申请
```

---

## 🎯 典型使用场景

### ✅ 场景1：正常编辑
```
运单状态：
- payment_status: 'Unpaid'
- invoice_status: 'Uninvoiced'

用户操作：
1. 页面显示：[✏️修改运费] [🔗修改链路]
2. 点击按钮：打开编辑对话框
3. 验证状态：✅ 两个状态都通过
4. 保存修改：✅ 成功
```

### ❌ 场景2：已申请支付
```
运单状态：
- payment_status: 'Processing'
- invoice_status: 'Uninvoiced'

页面显示：
- 操作列：已申请支付
- 鼠标悬停：不可编辑：已申请支付

用户无法点击编辑按钮
```

### ❌ 场景3：开票中
```
运单状态：
- payment_status: 'Unpaid'
- invoice_status: 'Processing'

页面显示：
- 操作列：开票中
- 鼠标悬停：不可编辑：开票中

用户无法点击编辑按钮
```

### ❌ 场景4：已开票
```
运单状态：
- payment_status: 'Unpaid'
- invoice_status: 'Invoiced'

页面显示：
- 操作列：已开票
- 鼠标悬停：不可编辑：已开票

用户无法点击编辑按钮
```

### ❌ 场景5：已付款已开票
```
运单状态：
- payment_status: 'Paid'
- invoice_status: 'Invoiced'

页面显示：
- 操作列：已完成支付（优先显示付款状态）
- 鼠标悬停：不可编辑：已完成支付

说明：当两个状态都不符合时，优先显示付款状态
```

---

## ⚠️ 错误提示

### 前端错误提示

#### 修改运费时

**付款状态错误**：
```
❌ 只有未支付状态的运单才能修改运费。当前付款状态：已申请支付
```

**开票状态错误**：
```
❌ 只有未开票状态的运单才能修改运费。当前开票状态：开票中
```

#### 修改链路时

**付款状态错误**：
```
❌ 只有未支付状态的运单才能修改合作链路。当前付款状态：已完成支付
```

**开票状态错误**：
```
❌ 只有未开票状态的运单才能修改合作链路。当前开票状态：已开票
```

### 后端错误提示

```json
{
  "success": false,
  "message": "只有未开票状态的运单才能修改合作链路。当前开票状态：开票中"
}
```

---

## 🔍 状态检查优先级

### UI显示优先级

1. **付款状态** > 开票状态
2. 如果付款状态不符 → 显示付款状态
3. 如果付款状态符合但开票状态不符 → 显示开票状态
4. 两个状态都符合 → 显示编辑按钮

```typescript
const getUneditableReason = (record) => {
  // 优先检查付款状态
  if (record.payment_status !== 'Unpaid') {
    return '已申请支付' / '已完成支付';
  }
  // 再检查开票状态
  if (record.invoice_status && record.invoice_status !== 'Uninvoiced') {
    return '开票中' / '已开票';
  }
  return '';
};
```

### 保存验证优先级

保存时两个状态**都会检查**，不分优先级：
1. 先检查付款状态
2. 再检查开票状态
3. 两个都通过才能保存

---

## 🛡️ 安全性分析（增强版）

### 可能的攻击场景与防护

| 攻击场景 | 防护措施 | 防护层 |
|---------|---------|--------|
| 修改DOM显示按钮 | 前端逻辑双重验证 | 第二层 |
| 绕过前端直接调用API | RPC函数双重验证 | 第三层 |
| 并发操作状态变更 | 保存前重新查询两个状态 | 第二+三层 |
| 只修改付款状态不修改开票状态 | 两个状态都会验证 | 全部三层 |
| 通过SQL工具修改 | RPC函数强制调用 | 第三层 |

### 数据一致性保证（增强）

1. **完整性**：同时保护付款和开票两条业务线
2. **原子性**：状态检查和数据更新在同一个事务中
3. **实时性**：每次操作都重新查询最新的两个状态
4. **可追溯性**：错误信息明确指出是哪个状态不符

---

## 📝 开发指导

### 添加新的编辑功能时

遵循双重状态检查模式：

```typescript
// 1. 辅助函数
const isRecordEditable = (record) => {
  const isPaymentEditable = record.payment_status === 'Unpaid';
  const isInvoiceEditable = !record.invoice_status || 
                            record.invoice_status === 'Uninvoiced';
  return isPaymentEditable && isInvoiceEditable;
};

// 2. UI判断
{isRecordEditable(record) && <Button>操作</Button>}

// 3. 保存前验证
const { data } = await supabase
  .from('logistics_records')
  .select('payment_status, invoice_status')
  .eq('id', recordId)
  .single();

if (data.payment_status !== 'Unpaid') {
  throw new Error('付款状态不符');
}
if (data.invoice_status && data.invoice_status !== 'Uninvoiced') {
  throw new Error('开票状态不符');
}
```

```sql
-- 4. 后端验证
IF v_payment_status != 'Unpaid' THEN
    RETURN json_build_object('success', false, ...);
END IF;

IF v_invoice_status IS NOT NULL AND v_invoice_status != 'Uninvoiced' THEN
    RETURN json_build_object('success', false, ...);
END IF;
```

---

## ✅ 测试清单（增强版）

### 功能测试

#### 基础场景
- [ ] Unpaid + Uninvoiced：✅ 可以修改运费和链路
- [ ] Unpaid + NULL：✅ 可以修改运费和链路
- [ ] Processing + Uninvoiced：❌ 不显示编辑按钮，显示"已申请支付"
- [ ] Paid + Uninvoiced：❌ 不显示编辑按钮，显示"已完成支付"
- [ ] Unpaid + Processing：❌ 不显示编辑按钮，显示"开票中"
- [ ] Unpaid + Invoiced：❌ 不显示编辑按钮，显示"已开票"

#### 复合场景
- [ ] Processing + Processing：❌ 显示"已申请支付"
- [ ] Processing + Invoiced：❌ 显示"已申请支付"
- [ ] Paid + Processing：❌ 显示"已完成支付"
- [ ] Paid + Invoiced：❌ 显示"已完成支付"

### 安全测试
- [ ] 通过开发工具显示隐藏按钮后点击：前端验证阻止
- [ ] 直接调用API修改已开票的运单：后端验证阻止
- [ ] 并发修改：A打开编辑框，B生成开票申请，A保存：验证阻止
- [ ] 错误提示明确指出是付款还是开票状态不符

### 边界测试
- [ ] invoice_status 为 NULL 视为 Uninvoiced
- [ ] 同时满足两个条件才能编辑
- [ ] 错误提示优先显示付款状态

---

## 🎉 总结

### 核心原则

**运单必须同时满足以下两个条件才能修改运费或合作链路：**
1. ✅ `payment_status = 'Unpaid'`
2. ✅ `invoice_status = NULL 或 'Uninvoiced'`

### 保护优势

1. ✅ **双重保护**：同时保护付款和开票两条业务线
2. ✅ **财务安全**：防止修改已进入任何审批流程的数据
3. ✅ **数据一致性**：确保财务记录的完整性和准确性
4. ✅ **用户体验**：清晰提示不可编辑的具体原因
5. ✅ **系统安全**：三层防护杜绝任何绕过尝试

---

## 📦 相关文件

### 前端
- `src/pages/PaymentRequest.tsx`
  - 第35行：添加 invoice_status 类型定义
  - 第133-148行：双重状态检查辅助函数
  - 第378-397行：修改运费双重状态验证
  - 第623-655行：UI双重状态判断

### 后端
- `supabase/migrations/20251025_fix_modify_chain_with_recalculation.sql`
  - 第28行：添加 v_invoice_status 变量
  - 第55行：SELECT 语句获取开票状态
  - 第74-98行：双重状态验证逻辑

### 文档
- `付款申请编辑完整状态保护说明.md` - 本文档

---

**实施日期**: 2025-10-25  
**测试状态**: 待测试  
**部署状态**: 待部署  
**保护级别**: 🛡️🛡️🛡️ 三层 × 双重状态 = 六重保护

