# 付款开票申请逻辑对比分析

## 📊 核心业务规则

### 合作方级别说明

假设一个运单有3个合作方：
```
项目 → 一级合作方（level=1）
     → 二级合作方（level=2）  
     → 三级合作方（level=3）← 最高级
```

### 付款 vs 开票方向

| 操作 | 给谁 | 级别条件 | 业务含义 |
|------|------|---------|---------|
| **付款** | 非最高级 | `level < maxLevel` | 往下游付款给中间商 |
| **开票** | 最高级 | `level === maxLevel` | 往上游客户开票收款 |

**示例：**
```
合作方结构：level 1 → level 2 → level 3(最高)

付款申请：
✅ 付给 level 1（一级合作方）
✅ 付给 level 2（二级合作方）
❌ 不付给 level 3（最高级，他们收钱）

开票申请：
❌ 不给 level 1 开票
❌ 不给 level 2 开票  
✅ 给 level 3 开票（最高级客户付钱给我们）
```

---

## 🔍 当前实现对比

### 付款申请 (PaymentRequest.tsx)

#### 前端传参

```typescript
const { error } = await supabase.rpc('process_payment_application', {
  p_record_ids: allRecordIds  // ⭐ 只传运单ID数组
});
```

#### 后端函数签名（应该是）

```sql
CREATE FUNCTION process_payment_application(p_record_ids uuid[])
RETURNS jsonb
```

#### 处理逻辑（后端）

```sql
1. 找出最高级别 maxLevel
2. 遍历运单ID
3. 获取每个运单的 partner_costs
4. 筛选 level < maxLevel 的合作方
5. 按合作方分组
6. 创建 payment_requests
7. 创建 partner_payment_items 明细
8. 更新运单或成本状态
```

---

### 开票申请 (InvoiceRequest.tsx)

#### 前端传参（当前）

```typescript
const { data, error } = await supabase.rpc('save_invoice_request', {
  p_invoice_data: finalInvoiceData  // ⭐ 传完整数据对象
});

// finalInvoiceData 结构：
{
  sheets: [...],  // 前端已分组
  all_record_ids: [...]  // 运单ID数组
}
```

#### 后端函数签名（有问题）

```sql
-- ❌ 当前有两个版本导致冲突
CREATE FUNCTION save_invoice_request(p_invoice_data json)
CREATE FUNCTION save_invoice_request(p_invoice_data jsonb)
```

---

## 💡 修复方案对比

### 方案A：统一为只传ID数组（推荐）

**优点：**
- ✅ 付款和开票逻辑完全一致
- ✅ 后端统一处理分组
- ✅ 前端代码更简单
- ✅ 数据传输量更小

**需要修改：**
- 前端：改为只传运单ID数组
- 后端：参数改为 `p_record_ids uuid[]`

**修改前端：**
```typescript
// InvoiceRequest.tsx
const { data, error } = await supabase.rpc('save_invoice_request', {
  p_record_ids: finalInvoiceData.all_record_ids  // 只传ID
});
```

**修改后端：**
```sql
CREATE FUNCTION save_invoice_request(p_record_ids uuid[])
-- 逻辑：
-- 1. 找maxLevel
-- 2. 只处理 level === maxLevel
-- 3. 按合作方分组
-- 4. 创建申请
```

---

### 方案B：保持传完整数据（不推荐）

**优点：**
- ✅ 前端不用改
- ✅ 前端已经分好组

**缺点：**
- ❌ 付款和开票逻辑不一致
- ❌ 数据传输量大
- ❌ 前后端逻辑重复
- ❌ 需要处理函数重载冲突

**实现：**
```sql
CREATE FUNCTION save_invoice_request(p_invoice_data jsonb)
-- 参数包含完整的sheets数据
-- 逻辑：直接使用前端分好的组
```

---

## 🎯 我的建议：方案A

### 修改前端调用

```typescript
// src/pages/InvoiceRequest.tsx 第442行
const { data, error } = await supabase.rpc('save_invoice_request', {
  p_record_ids: finalInvoiceData.all_record_ids  // 改为只传ID数组
});
```

### 后端函数

```sql
CREATE FUNCTION public.save_invoice_request(p_record_ids uuid[])
RETURNS jsonb
AS $$
DECLARE
  v_max_level integer;
BEGIN
  -- 1. 找出最高级别
  SELECT MAX(level) INTO v_max_level
  FROM logistics_partner_costs
  WHERE logistics_record_id = ANY(p_record_ids)
    AND invoice_status = 'Uninvoiced';
  
  -- 2. 按合作方分组，只处理最高级（level === maxLevel）
  FOR v_partner_id IN 
    SELECT DISTINCT partner_id
    FROM logistics_partner_costs
    WHERE logistics_record_id = ANY(p_record_ids)
      AND level = v_max_level  -- ⭐ 开票给最高级
      AND invoice_status = 'Uninvoiced'
  LOOP
    -- 3. 创建开票申请
    -- 4. 创建明细
    -- 5. 更新状态
  END LOOP;
  
  RETURN result;
END;
$$;
```

---

## 📋 完整的数据流

### 付款申请数据流

```
用户选择运单
    ↓
前端调用：process_payment_application(运单ID数组)
    ↓
后端处理：
  ├─ 找出 maxLevel = 3
  ├─ 筛选 level < 3 的合作方（level 1, 2）
  ├─ 按合作方ID分组
  ├─ 创建 payment_requests (一个合作方一条)
  ├─ 创建 partner_payment_items (明细)
  └─ 更新状态
    ↓
返回：创建的申请列表
```

### 开票申请数据流（应该类似）

```
用户选择运单
    ↓
前端调用：save_invoice_request(运单ID数组)  ⭐ 只传ID
    ↓
后端处理：
  ├─ 找出 maxLevel = 3
  ├─ 筛选 level === 3 的合作方（⭐ 只要最高级）
  ├─ 按合作方ID分组
  ├─ 创建 invoice_requests (一个合作方一条)
  ├─ 创建 invoice_request_details (明细)
  └─ 更新 logistics_partner_costs.invoice_status
    ↓
返回：创建的申请列表
```

---

## ✅ 修复建议

### 我已经实现的（在迁移文件中）

✅ 参数改为 `p_record_ids uuid[]`  
✅ 找出最高级别  
✅ 只处理 `level === maxLevel`  
✅ 按合作方分组  
✅ 创建申请和明细  
✅ 更新状态  

### 还需要做的

❓ **前端是否需要修改？**

**如果前端不改：**
- 后端接受 `p_invoice_data jsonb`
- 直接用前端的sheets数据
- 不用重新分组

**如果前端改（推荐）：**
- 后端接受 `p_record_ids uuid[]`
- 后端自己分组
- 逻辑统一

---

**请问您想用哪个方案？**
- 方案A：前端改为只传ID，后端处理分组（统一、推荐）
- 方案B：前端不改，后端接受完整数据（当前兼容）

我的迁移文件目前是**方案A**，如果需要方案B我可以调整！
