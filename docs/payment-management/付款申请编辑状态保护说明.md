# 付款申请编辑状态保护说明

## 📅 完成日期
2025-10-25

## 🔒 核心保护逻辑

### 问题背景

运单在付款流程中可能处于不同状态：
- **Unpaid** - 未支付
- **Processing** - 已申请支付（审核中）
- **Paid** - 已完成支付

**关键问题**：已经进入付款流程（Processing）或已完成支付（Paid）的运单，如果允许修改运费或合作链路，会导致：
- ❌ 财务数据不一致
- ❌ 已生成的付款申请单与实际不符
- ❌ 审批流程混乱
- ❌ 对账错误

---

## ✅ 实施的保护措施

### 1. **前端UI保护**（第一道防线）

#### 实现位置
`src/pages/PaymentRequest.tsx` - 第589-624行

#### 保护逻辑

```typescript
{r.payment_status === 'Unpaid' ? (
  // 只有未支付状态才显示编辑按钮
  <>
    <Button>✏️ 修改运费</Button>
    <Button>🔗 修改链路</Button>
  </>
) : (
  // 其他状态显示状态文本
  <span className="text-xs text-muted-foreground">
    {r.payment_status === 'Processing' ? '已申请' : '已付款'}
  </span>
)}
```

#### 效果

| 运单状态 | 显示内容 | 说明 |
|---------|---------|------|
| **Unpaid** | ✏️ 🔗 按钮 | 可以编辑 |
| **Processing** | "已申请" 文本 | 不可编辑 |
| **Paid** | "已付款" 文本 | 不可编辑 |

---

### 2. **前端逻辑保护**（第二道防线）

#### 修改运费保护

**实现位置**：`src/pages/PaymentRequest.tsx` - 第360-372行

```typescript
const handleSavePartnerCost = async () => {
  // 1. 查询运单当前状态
  const { data: recordData } = await supabase
    .from('logistics_records')
    .select('payment_status')
    .eq('id', editPartnerCostData.recordId)
    .single();
  
  // 2. 验证状态
  if (recordData.payment_status !== 'Unpaid') {
    const statusText = recordData.payment_status === 'Processing' 
      ? '已申请支付' 
      : '已完成支付';
    throw new Error(`只有未支付状态的运单才能修改运费。当前状态：${statusText}`);
  }
  
  // 3. 状态正确，继续执行更新
  // ...
};
```

**保护场景**：
- 防止通过浏览器开发工具绕过UI限制
- 防止并发修改（用户A打开编辑框时状态是Unpaid，但保存时已被用户B改为Processing）

---

### 3. **后端数据库保护**（第三道防线，最终防线）

#### 实现位置
`supabase/migrations/20251025_fix_modify_chain_with_recalculation.sql` - 第70-81行

#### RPC函数保护

```sql
CREATE OR REPLACE FUNCTION modify_logistics_record_chain_with_recalc(
    p_record_id UUID,
    p_chain_name TEXT
)
RETURNS JSON AS $$
DECLARE
    v_payment_status TEXT;
BEGIN
    -- 1. 获取运单信息（包含支付状态）
    SELECT payment_status
    INTO v_payment_status
    FROM logistics_records
    WHERE id = p_record_id;
    
    -- 2. 验证状态
    IF v_payment_status != 'Unpaid' THEN
        RETURN json_build_object(
            'success', false,
            'message', '只有未支付状态的运单才能修改合作链路。当前状态：' || 
                CASE 
                    WHEN v_payment_status = 'Processing' THEN '已申请支付'
                    WHEN v_payment_status = 'Paid' THEN '已完成支付'
                    ELSE v_payment_status
                END
        );
    END IF;
    
    -- 3. 状态正确，继续执行修改
    -- ...
END;
$$;
```

**保护场景**：
- 防止直接调用API绕过前端验证
- 防止通过SQL工具直接修改
- 防止其他系统/脚本误操作
- 数据库级别的最终保护

---

## 🎯 三层防护体系

### 防护示意图

```
用户操作
  ↓
┌─────────────────────────────────┐
│  第一层：前端UI                  │
│  - 非Unpaid状态不显示编辑按钮    │
│  - 显示当前状态提示              │
└─────────────────────────────────┘
  ↓ (如果绕过UI)
┌─────────────────────────────────┐
│  第二层：前端业务逻辑            │
│  - 保存前查询最新状态            │
│  - 验证状态是否为Unpaid          │
│  - 不符合则抛出错误              │
└─────────────────────────────────┘
  ↓ (如果绕过前端)
┌─────────────────────────────────┐
│  第三层：数据库RPC函数           │
│  - 函数内部再次验证状态          │
│  - 只允许Unpaid状态修改          │
│  - 返回明确的错误信息            │
└─────────────────────────────────┘
  ↓
数据库更新（只有通过三层验证才能到达）
```

---

## 📊 状态流转规则

### 正常流程

```
1. 创建运单
   ↓
   payment_status = 'Unpaid'
   ✅ 可以修改运费
   ✅ 可以修改链路

2. 生成付款申请
   ↓
   payment_status = 'Processing'
   ❌ 不能修改运费
   ❌ 不能修改链路

3. 完成支付
   ↓
   payment_status = 'Paid'
   ❌ 不能修改运费
   ❌ 不能修改链路
```

### 特殊情况：撤销付款申请

```
如果需要修改已申请的运单：

1. 先撤销付款申请
   ↓
   payment_status 恢复为 'Unpaid'
   
2. 然后修改运费/链路
   ↓
   修改完成
   
3. 重新生成付款申请
   ↓
   payment_status 变为 'Processing'
```

---

## 🔍 用户体验

### 未支付状态（Unpaid）

**显示**：
```
[✏️修改运费] [🔗修改链路]
```

**操作**：
- ✅ 可以点击按钮
- ✅ 打开编辑对话框
- ✅ 保存成功

---

### 已申请状态（Processing）

**显示**：
```
已申请
```

**操作**：
- ❌ 没有按钮可点击
- 💡 提示：运单已进入审批流程，如需修改请先撤销付款申请

---

### 已付款状态（Paid）

**显示**：
```
已付款
```

**操作**：
- ❌ 没有按钮可点击
- 💡 提示：运单已完成支付，无法修改。如有问题请联系财务人员

---

## ⚠️ 错误提示

### 前端错误提示

**修改运费时**：
```
❌ 只有未支付状态的运单才能修改运费。当前状态：已申请支付
```

**修改链路时**：
```
❌ 只有未支付状态的运单才能修改合作链路。当前状态：已完成支付
```

### 后端错误提示（通过API直接调用）

```json
{
  "success": false,
  "message": "只有未支付状态的运单才能修改合作链路。当前状态：已申请支付"
}
```

---

## 🛡️ 安全性分析

### 可能的攻击场景与防护

| 攻击场景 | 防护措施 | 防护层 |
|---------|---------|--------|
| 修改DOM显示按钮 | 前端逻辑验证 | 第二层 |
| 绕过前端直接调用API | RPC函数验证 | 第三层 |
| 通过SQL工具修改 | RPC函数强制调用 | 第三层 |
| 并发操作状态变更 | 保存前重新查询状态 | 第二+三层 |
| 权限绕过 | `is_finance_operator_or_admin()` | 第三层 |

### 数据一致性保证

1. **原子性**：状态检查和数据更新在同一个事务中
2. **实时性**：每次操作都查询最新状态，不使用缓存
3. **完整性**：三层验证确保没有漏洞

---

## 📝 开发指导

### 添加新的编辑功能时

如果将来需要添加其他编辑功能，请遵循相同的三层防护模式：

1. **前端UI**：根据状态决定是否显示操作按钮
2. **前端逻辑**：操作前验证状态
3. **后端RPC**：函数内部再次验证状态

### 示例代码模板

```typescript
// 前端UI
{record.payment_status === 'Unpaid' && (
  <Button onClick={handleEdit}>编辑</Button>
)}

// 前端逻辑
const handleEdit = async () => {
  const { data } = await supabase
    .from('logistics_records')
    .select('payment_status')
    .eq('id', recordId)
    .single();
  
  if (data.payment_status !== 'Unpaid') {
    throw new Error('只有未支付状态才能编辑');
  }
  
  // 继续执行...
};
```

```sql
-- 后端RPC
CREATE FUNCTION edit_something(p_record_id UUID)
RETURNS JSON AS $$
DECLARE
    v_payment_status TEXT;
BEGIN
    SELECT payment_status INTO v_payment_status
    FROM logistics_records
    WHERE id = p_record_id;
    
    IF v_payment_status != 'Unpaid' THEN
        RETURN json_build_object(
            'success', false,
            'message', '只有未支付状态才能编辑'
        );
    END IF;
    
    -- 继续执行...
END;
$$;
```

---

## ✅ 测试清单

### 功能测试

- [ ] 未支付运单：可以修改运费
- [ ] 未支付运单：可以修改链路
- [ ] 已申请运单：不显示编辑按钮
- [ ] 已付款运单：不显示编辑按钮
- [ ] 状态提示文本正确显示

### 安全测试

- [ ] 通过开发工具显示隐藏按钮后点击：前端验证阻止
- [ ] 直接调用API修改已申请的运单：后端验证阻止
- [ ] 并发修改测试：A打开编辑框，B生成付款申请，A保存：验证阻止
- [ ] 错误提示信息清晰准确

### 边界测试

- [ ] 刚好在生成付款申请时修改：事务保护
- [ ] 网络延迟导致状态不一致：重新查询验证
- [ ] 数据库状态字段为NULL：错误处理

---

## 🎉 总结

实施的三层防护体系确保：

1. ✅ **用户体验好**：UI清晰提示，不会让用户尝试无效操作
2. ✅ **数据安全**：三层验证，杜绝误操作和恶意攻击
3. ✅ **财务准确**：保护已进入流程的数据不被修改
4. ✅ **可维护性**：代码结构清晰，易于扩展

**核心原则**：只有 `payment_status = 'Unpaid'` 的运单才能修改运费或合作链路！

---

## 📦 相关文件

### 前端
- `src/pages/PaymentRequest.tsx`
  - 第589-624行：UI状态判断
  - 第360-372行：修改运费状态验证
  - 第405-420行：修改链路调用（状态验证在RPC中）

### 后端
- `supabase/migrations/20251025_fix_modify_chain_with_recalculation.sql`
  - 第27行：添加 v_payment_status 变量
  - 第70-81行：状态验证逻辑

### 文档
- `付款申请编辑状态保护说明.md` - 本文档

---

**实施日期**: 2025-10-25  
**测试状态**: 待测试  
**部署状态**: 待部署

