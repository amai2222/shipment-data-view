# 链路计算逻辑说明

## 📋 目录

1. [核心概念](#核心概念)
2. [数据结构](#数据结构)
3. [计算逻辑](#计算逻辑)
4. [重算机制](#重算机制)
5. [手工修改保护](#手工修改保护)
6. [实际案例](#实际案例)

---

## 核心概念

### 1. 链路（Chain）

**链路**是项目中的一个**合作路径**，定义了该路径上涉及的所有合作方及其层级关系。

- 一个项目可以有多个链路
- 每个链路包含多个合作方（按层级排列）
- 每个运单必须关联一个链路

### 2. 合作方层级（Level）

链路中的合作方按照**层级（level）**排列，从低到高：

```
Level 1: 司机（最底层）
Level 2: 一级合作方
Level 3: 二级合作方
Level 4: 三级合作方
...
```

**重要规则**：
- ✅ **每个层级都独立从司机应收（payable_cost）开始计算**
- ✅ **不级联**：Level 2 不是基于 Level 1 的结果，而是基于 payable_cost
- ✅ **所有层级的基础金额都是 payable_cost**

### 3. 司机应收（payable_cost）

**payable_cost** = **current_cost**（当前成本）+ **extra_cost**（额外成本）

这是所有合作方成本计算的**基础金额**。

---

## 数据结构

### 1. 运单表（logistics_records）

```sql
- id: 运单ID
- project_id: 项目ID
- chain_id: 链路ID
- current_cost: 当前成本
- extra_cost: 额外成本
- payable_cost: 司机应收（= current_cost + extra_cost）
- loading_weight: 装货重量
- unloading_weight: 卸货重量
```

### 2. 链路表（partner_chains）

```sql
- id: 链路ID
- project_id: 项目ID
- chain_name: 链路名称
- billing_type_id: 计费类型ID
```

### 3. 项目合作方表（project_partners）

```sql
- project_id: 项目ID
- chain_id: 链路ID
- partner_id: 合作方ID
- level: 层级（1, 2, 3, ...）
- tax_rate: 税点（0-1之间的小数，如 0.06 表示 6%）
- calculation_method: 计算方法（'tax' 或 'profit'）
- profit_rate: 利润（当计算方法为 'profit' 时使用）
```

### 4. 合作方成本表（logistics_partner_costs）

```sql
- logistics_record_id: 运单ID
- partner_id: 合作方ID
- level: 层级
- base_amount: 基础金额（= payable_cost）
- payable_amount: 应付金额（计算后的结果）
- tax_rate: 税点
- is_manually_modified: 是否手工修改（true/false）
```

---

## 计算逻辑

### 两种计算方法

#### 方法1：税点法（tax）- 默认方法

**公式**：
```
应付金额 = 基础金额 / (1 - 税点)
```

**示例**：
- 基础金额（payable_cost）= 1000 元
- 税点（tax_rate）= 0.06（6%）
- 应付金额 = 1000 / (1 - 0.06) = 1000 / 0.94 = 1063.83 元

**代码实现**：
```sql
IF v_project_partners.tax_rate IS NOT NULL AND v_project_partners.tax_rate != 1 THEN
    v_payable_amount := v_base_amount / (1 - v_project_partners.tax_rate);
ELSE
    v_payable_amount := v_base_amount;  -- 税点为0或1时，不计算
END IF;
```

#### 方法2：利润法（profit）

**公式**：
```
如果装货重量 > 0：
    应付金额 = 基础金额 + (利润 × 装货重量)
否则：
    应付金额 = 基础金额 + 利润
```

**示例**：
- 基础金额（payable_cost）= 1000 元
- 利润（profit_rate）= 50 元/吨
- 装货重量（loading_weight）= 20 吨
- 应付金额 = 1000 + (50 × 20) = 1000 + 1000 = 2000 元

**代码实现**：
```sql
IF v_project_partners.calculation_method = 'profit' THEN
    IF v_loading_weight IS NOT NULL AND v_loading_weight > 0 THEN
        v_payable_amount := v_base_amount + (COALESCE(v_project_partners.profit_rate, 0) * v_loading_weight);
    ELSE
        v_payable_amount := v_base_amount + COALESCE(v_project_partners.profit_rate, 0);
    END IF;
END IF;
```

### 计算流程

```
1. 获取运单的 payable_cost（司机应收）
   ↓
2. 查询该链路的所有合作方（按 level 排序）
   ↓
3. 遍历每个合作方：
   ├─ 基础金额 = payable_cost（所有层级都用这个）
   ├─ 根据计算方法计算应付金额
   │  ├─ 税点法：base / (1 - tax_rate)
   │  └─ 利润法：base + (profit_rate × weight)
   └─ 插入到 logistics_partner_costs 表
```

---

## 重算机制

### 触发重算的场景

1. **创建新运单**：自动计算所有合作方成本
2. **修改运单的 payable_cost**：自动重算（通过触发器）
3. **修改链路配置**：批量重算该链路的所有运单
4. **手动触发重算**：对账管理页面的"一键重算"功能

### 重算函数

#### 1. `recalculate_and_update_costs_for_record(record_id)`

**功能**：重算单个运单的合作方成本

**逻辑**：
1. 删除旧的成本记录（`is_manually_modified = false`）
2. 保留手工修改的记录（`is_manually_modified = true`）
3. 重新计算所有合作方成本
4. 跳过已手工修改的合作方

#### 2. `recalculate_costs_for_chain(project_id, chain_id)`

**功能**：重算指定链路的所有运单成本

**逻辑**：
1. 遍历该链路的所有运单
2. 对每个运单执行重算逻辑

#### 3. `batch_recalculate_partner_costs(record_ids[])`

**功能**：批量重算多个运单的成本

**逻辑**：
1. 遍历每个运单ID
2. 跳过已付款或已开票的运单
3. 对每个运单执行重算逻辑

### 自动重算触发器

**触发器名称**：`trigger_recalc_on_payable_cost_change`

**触发条件**：当 `logistics_records.payable_cost` 改变时

**执行逻辑**：
```sql
1. 检查运单状态（已付款或已开票则跳过）
2. 保存所有手工修改的成本记录
3. 删除系统计算的成本记录（is_manually_modified = false）
4. 重新计算所有合作方成本
5. 跳过已手工修改的合作方
```

---

## 手工修改保护

### 保护机制

系统支持**手工修改**合作方成本，修改后的值会被保护，不会被自动重算覆盖。

### 实现方式

1. **标记字段**：`logistics_partner_costs.is_manually_modified`
   - `true`：手工修改，受保护
   - `false`：系统计算，可重算

2. **保护逻辑**：
   ```sql
   -- 重算前：保存所有手工修改的记录
   SELECT json_agg(...)
   INTO v_manually_modified_costs
   FROM logistics_partner_costs
   WHERE logistics_record_id = record_id
   AND is_manually_modified = true;
   
   -- 重算时：跳过已手工修改的合作方
   IF EXISTS (手工修改记录) THEN
       CONTINUE;  -- 跳过，不重算
   END IF;
   ```

3. **删除策略**：
   - ✅ 删除：`is_manually_modified = false` 的记录（系统计算的）
   - ❌ 保留：`is_manually_modified = true` 的记录（手工修改的）

---

## 实际案例

### 案例1：税点法计算

**场景**：
- 项目：测试项目
- 链路：默认链路
- 运单：
  - current_cost = 1000 元
  - extra_cost = 100 元
  - payable_cost = 1100 元
  - loading_weight = 20 吨

**链路配置**：
- Level 1（司机）：不计算（直接使用 payable_cost）
- Level 2（一级合作方）：税点法，tax_rate = 0.06（6%）
- Level 3（二级合作方）：税点法，tax_rate = 0.03（3%）

**计算结果**：

| 层级 | 合作方 | 基础金额 | 税点 | 计算方法 | 应付金额 |
|------|--------|----------|------|----------|----------|
| 1 | 司机 | 1100 | - | - | 1100 |
| 2 | 一级合作方 | 1100 | 6% | 税点法 | 1100 / (1 - 0.06) = 1170.21 |
| 3 | 二级合作方 | 1100 | 3% | 税点法 | 1100 / (1 - 0.03) = 1134.02 |

**注意**：
- ✅ Level 2 和 Level 3 都从 1100 开始计算（不级联）
- ✅ Level 2 的结果（1170.21）不影响 Level 3 的计算

### 案例2：利润法计算

**场景**：
- 运单：
  - payable_cost = 1000 元
  - loading_weight = 20 吨

**链路配置**：
- Level 2（一级合作方）：利润法，profit_rate = 50 元/吨

**计算结果**：

| 层级 | 合作方 | 基础金额 | 利润 | 计算方法 | 应付金额 |
|------|--------|----------|------|----------|----------|
| 2 | 一级合作方 | 1000 | 50元/吨 | 利润法 | 1000 + (50 × 20) = 2000 |

### 案例3：混合计算

**场景**：
- 运单：
  - payable_cost = 1000 元
  - loading_weight = 20 吨

**链路配置**：
- Level 2（一级合作方）：税点法，tax_rate = 0.06
- Level 3（二级合作方）：利润法，profit_rate = 30 元/吨

**计算结果**：

| 层级 | 合作方 | 基础金额 | 参数 | 计算方法 | 应付金额 |
|------|--------|----------|------|----------|----------|
| 2 | 一级合作方 | 1000 | 6% | 税点法 | 1000 / 0.94 = 1063.83 |
| 3 | 二级合作方 | 1000 | 30元/吨 | 利润法 | 1000 + (30 × 20) = 1600 |

---

## 关键要点总结

### ✅ 重要规则

1. **所有层级的基础金额都是 payable_cost**
   - Level 1、Level 2、Level 3... 都从同一个基础金额开始计算

2. **不级联计算**
   - Level 2 的结果不影响 Level 3
   - 每个层级独立计算

3. **两种计算方法**
   - **税点法**：`base / (1 - tax_rate)`
   - **利润法**：`base + (profit_rate × weight)`

4. **手工修改保护**
   - `is_manually_modified = true` 的记录不会被重算覆盖
   - 重算时自动跳过已手工修改的合作方

5. **自动重算触发**
   - 创建新运单时自动计算
   - 修改 payable_cost 时自动重算（触发器）
   - 修改链路配置时批量重算

### ⚠️ 注意事项

1. **金额精度**：所有金额保留 2 位小数（`ROUND(amount, 2)`）

2. **已付款/已开票保护**：
   - 已付款或已开票的运单不会自动重算
   - 需要手动触发重算

3. **空值处理**：
   - 如果税点为 NULL 或 1，则不计算（直接使用基础金额）
   - 如果装货重量为 NULL 或 0，利润法使用固定利润值

---

## 相关函数列表

| 函数名 | 功能 | 参数 |
|--------|------|------|
| `recalculate_and_update_costs_for_record` | 重算单个运单成本 | `record_id` |
| `recalculate_costs_for_chain` | 重算链路所有运单成本 | `project_id, chain_id` |
| `batch_recalculate_partner_costs` | 批量重算成本 | `record_ids[]` |
| `modify_logistics_record_chain_with_recalc` | 修改链路并重算 | `record_id, chain_name` |

---

**文档创建日期**：2025-11-16  
**最后更新**：2025-11-16

