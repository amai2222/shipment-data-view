# 单价功能最终修复说明

## 📅 日期
2025-11-20

## 🐛 问题描述

用户反馈：编辑运单并输入单价后，`effective_quantity`（有效数量）和 `current_cost`（运费）没有保存到数据库。

## 🔍 问题分析

经过多轮调试和分析，发现问题的根源可能是：

### 1. 触发器冲突
- `logistics_records` 表上有一个 `BEFORE UPDATE` 触发器：`trigger_auto_calculate_cost_from_unit_price_1120`
- 这个触发器会在 UPDATE 执行前自动计算 `effective_quantity` 和 `current_cost`
- 但是 RPC 函数 `update_logistics_record_via_recalc_1120` 也在计算这些值
- **触发器和函数可能产生冲突**，导致值没有正确保存

### 2. 触发器触发条件
- 触发器只在特定字段更新时触发：
  ```sql
  UPDATE OF unit_price, loading_weight, unloading_weight, extra_cost, chain_id, project_id
  ```
- 如果某些字段没有变化，触发器可能不会触发
- 或者触发器触发了，但计算结果被函数覆盖

### 3. 计算顺序问题
- PostgreSQL 的更新流程：
  1. UPDATE 语句开始执行
  2. 创建 NEW 记录（包含 UPDATE 语句中设置的新值）
  3. BEFORE UPDATE 触发器执行，修改 NEW 记录
  4. 实际的 UPDATE 操作使用触发器修改后的 NEW 记录
  5. AFTER UPDATE 触发器执行
- **问题**：函数中设置的值和触发器计算的值可能不一致

## 💡 解决方案

### 方案概述

**禁用 BEFORE UPDATE 触发器，让 RPC 函数完全控制数据的计算和设置。**

### 实施步骤

1. **创建详细调试版本的 RPC 函数**
   - 在函数内部完成所有计算逻辑
   - 显式设置 `effective_quantity`、`current_cost`、`payable_cost`
   - 添加详细日志，输出所有计算步骤

2. **禁用 BEFORE UPDATE 触发器**
   - 执行 `ALTER TABLE logistics_records DISABLE TRIGGER trigger_auto_calculate_cost_from_unit_price_1120`
   - 避免触发器和函数之间的冲突

3. **验证保存结果**
   - 在函数内部，UPDATE 后立即读取数据库
   - 确认值是否正确保存
   - 输出警告信息（如果值仍为 NULL 或 0）

## 📋 执行步骤

### 1. 执行修复 SQL 文件

```bash
# 在 Supabase SQL Editor 中执行
supabase/migrations/20251120_final_fix_with_debug.sql
```

此文件会：
- 创建新版本的 `update_logistics_record_via_recalc_1120` 函数（包含详细日志）
- 禁用 `trigger_auto_calculate_cost_from_unit_price_1120` 触发器
- 输出验证信息

### 2. 测试运单编辑

1. 打开运单管理页面
2. 编辑一个现有运单
3. 输入单价（例如：100）
4. 观察界面是否显示有效数量和运费
5. 点击保存

### 3. 查看数据库日志

保存后，在 Supabase Logs 中应该看到类似以下的日志：

```
========================================
开始更新运单: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
========================================
输入参数:
  项目ID: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
  链路ID: xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx
  装货重量: 10.5
  卸货重量: 10.3
  单价: 100
  运费(传入): 0
  额外费用: 0

旧值:
  旧单价: NULL
  旧有效数量: NULL
  旧运费: 0

计算模式: auto
计算的有效数量: 10.3
自动计算运费: 100 × 10.3 = 1030.00

准备保存的值:
  calculation_mode: auto
  effective_quantity: 10.3
  current_cost: 1030.00
  payable_cost: 1030.00

UPDATE 语句已执行

保存后的实际值:
  calculation_mode: auto
  unit_price: 100
  effective_quantity: 10.3
  current_cost: 1030.00

========================================
更新完成
========================================
```

### 4. 验证数据库

在 Supabase SQL Editor 中执行：

```sql
-- 查询刚才编辑的运单
SELECT 
    id,
    unit_price,
    effective_quantity,
    current_cost,
    calculation_mode,
    loading_weight,
    unloading_weight,
    payable_cost
FROM logistics_records
WHERE id = 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx';
```

确认：
- ✅ `unit_price` 已保存
- ✅ `effective_quantity` 已保存且不为 NULL 或 0
- ✅ `current_cost` 已保存且等于 `unit_price × effective_quantity`
- ✅ `calculation_mode` = 'auto'
- ✅ `payable_cost` = `current_cost + extra_cost`

## 🔧 技术细节

### RPC 函数计算逻辑

```sql
-- 1. 判断计算模式
v_is_auto_mode := (p_unit_price IS NOT NULL AND p_unit_price > 0);

-- 2. 计算有效数量（根据链路计费模式和项目配置）
v_effective_quantity := public.get_effective_quantity_for_record_1120(
    p_loading_weight,
    p_unloading_weight,
    p_project_id,
    p_chain_id
);

-- 3. 计算运费
IF v_is_auto_mode THEN
    v_calculated_cost := p_unit_price * v_effective_quantity;
    v_calculated_cost := ROUND(v_calculated_cost, 2);
ELSE
    v_calculated_cost := COALESCE(p_current_cost, 0);
END IF;

-- 4. 更新记录
UPDATE logistics_records
SET 
    unit_price = p_unit_price,
    calculation_mode = CASE WHEN v_is_auto_mode THEN 'auto' ELSE 'manual' END,
    effective_quantity = v_effective_quantity,
    current_cost = v_calculated_cost,
    payable_cost = v_calculated_cost + COALESCE(p_extra_cost, 0),
    ...
WHERE id = p_record_id;
```

### 有效数量计算逻辑

`get_effective_quantity_for_record_1120` 函数：

1. **获取链路的计费模式**（`billing_type_id`）
2. **如果是计车模式（type 2）**：有效数量固定为 1
3. **如果是其他模式（计重/计方/计件）**：根据项目的 `effective_quantity_type` 配置：
   - `'loading'`：使用装货重量
   - `'unloading'`：使用卸货重量
   - `'min_value'`：使用两者中的较小值

## ⚠️ 注意事项

### 1. 触发器已禁用

`trigger_auto_calculate_cost_from_unit_price_1120` 触发器已被禁用。

- ✅ **优点**：避免触发器和函数冲突，数据保存更可靠
- ⚠️ **注意**：如果有其他地方直接 UPDATE `logistics_records` 表（不通过 RPC 函数），这些更新不会自动计算 `effective_quantity` 和 `current_cost`

### 2. 其他触发器仍在运行

以下触发器仍在运行（不受影响）：

- `trigger_recalc_on_payable_cost_change`：司机应收改变时自动重算合作方成本
- 其他业务触发器

### 3. 新增运单

新增运单使用的是 `add_logistics_record_with_costs_1120` 函数，该函数仍然依赖触发器。

**建议**：如果更新运单的修复验证成功，也应该修改新增运单的函数，使用相同的显式计算逻辑。

## 📊 验证清单

- [ ] 执行 `20251120_final_fix_with_debug.sql`
- [ ] 触发器已禁用
- [ ] 编辑运单并输入单价
- [ ] 界面显示有效数量和运费
- [ ] 点击保存
- [ ] 查看数据库日志（看到详细计算过程）
- [ ] 查询数据库，确认 `effective_quantity` 和 `current_cost` 已正确保存
- [ ] 测试不同的计费模式（计重、计车、计方、计件）
- [ ] 测试不同的项目配置（装货、卸货、最小值）

## 🎯 预期结果

执行修复后：

1. ✅ 编辑运单并输入单价后，`effective_quantity` 正确计算并保存
2. ✅ `current_cost` 正确计算并保存（= `unit_price × effective_quantity`）
3. ✅ `calculation_mode` 正确设置为 'auto'
4. ✅ `payable_cost` 正确计算并保存（= `current_cost + extra_cost`）
5. ✅ 数据库日志输出详细的计算过程
6. ✅ 界面显示正确的有效数量和运费

## 📝 后续优化

如果此修复验证成功，建议：

1. **统一新增和更新逻辑**
   - 修改 `add_logistics_record_with_costs_1120`，使用相同的显式计算逻辑
   - 完全移除对触发器的依赖

2. **删除或重构触发器**
   - 考虑完全删除 `trigger_auto_calculate_cost_from_unit_price_1120`
   - 或者重构触发器，只在直接 UPDATE 表时使用（不是通过 RPC 函数）

3. **简化日志**
   - 验证成功后，可以移除部分调试日志
   - 保留关键的计算步骤日志

---

**文件位置**：`docs/单价功能最终修复说明.md`  
**创建时间**：2025-11-20  
**状态**：待验证

