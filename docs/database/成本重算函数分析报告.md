# 成本重算函数分析报告

## 🔍 发现的问题

**您的观察非常敏锐！** 

系统中**存在多个成本重算函数**，它们都包含**相同的计算逻辑代码**（重复代码）。

---

## 📊 成本重算函数清单

### 1. `recalculate_costs_for_chain`

**位置**：`supabase/migrations/20250122_auto_recalc_on_project_partner_change.sql` (第17行)

**功能**：重新计算指定链路的所有运单成本

**参数**：
```sql
p_project_id UUID,
p_chain_id UUID
```

**核心计算逻辑**（第68-83行）：
```sql
IF v_project_partners.calculation_method = 'profit' THEN
    -- 利润法
    IF v_loading_weight IS NOT NULL AND v_loading_weight > 0 THEN
        v_payable_amount := v_base_amount + (v_profit_rate * v_loading_weight);
    ELSE
        v_payable_amount := v_base_amount + v_profit_rate;
    END IF;
ELSE
    -- 税点法（默认）
    IF v_tax_rate IS NOT NULL AND v_tax_rate != 1 THEN
        v_payable_amount := v_base_amount / (1 - v_tax_rate);
    ELSE
        v_payable_amount := v_base_amount;
    END IF;
END IF;
```

---

### 2. `recalculate_costs_for_chain_safe`

**位置**：`supabase/migrations/20250122_auto_recalc_on_project_partner_change.sql` (第235行)

**功能**：安全重算指定链路（可选择只重算未付款运单）

**参数**：
```sql
p_project_id UUID,
p_chain_id UUID,
p_only_unpaid BOOLEAN DEFAULT TRUE
```

**核心计算逻辑**：**与函数1完全相同** ❌（代码重复）

---

### 3. `modify_logistics_record_chain_with_recalc`

**位置**：`supabase/migrations/20251025_fix_modify_chain_with_recalculation.sql` (第32行)

**功能**：修改单个运单的合作链路并重新计算成本

**参数**：
```sql
p_record_id UUID,
p_chain_name TEXT
```

**核心计算逻辑**（第156-170行）：**与函数1完全相同** ❌（代码重复）

---

### 4. `batch_modify_chain`

**位置**：`supabase/migrations/20251025_add_batch_modify_functions.sql` (第104行)

**功能**：批量修改运单的合作链路并重新计算成本

**参数**：
```sql
p_record_ids UUID[],
p_chain_name TEXT
```

**实现方式**：调用 `modify_logistics_record_chain_with_recalc` 函数（复用了函数3）

---

### 5. `recalculate_costs_for_project`

**位置**：`supabase/migrations/20250122_auto_recalc_on_project_partner_change.sql` (第192行)

**功能**：重新计算整个项目所有链路的运单成本

**实现方式**：循环调用 `recalculate_costs_for_chain` 函数（复用了函数1）

---

## ⚠️ 问题分析

### 代码重复问题

**相同的计算逻辑在至少3个函数中重复出现**：

1. ✅ `recalculate_costs_for_chain`
2. ❌ `recalculate_costs_for_chain_safe` - **重复**
3. ❌ `modify_logistics_record_chain_with_recalc` - **重复**

### 重复的代码段（约30行）

```sql
-- 计算应付金额的逻辑（在3个函数中重复）
IF v_project_partners.calculation_method = 'profit' THEN
    -- 利润法计算
    ...
ELSE
    -- 税点法计算
    ...
END IF;

-- 插入成本记录的逻辑（在3个函数中重复）
INSERT INTO logistics_partner_costs (...) VALUES (...);
```

---

## 📋 重构建议

### 方案：提取核心计算函数

创建一个**通用的成本计算函数**：

```sql
CREATE OR REPLACE FUNCTION public.calculate_partner_cost(
    p_base_amount NUMERIC,
    p_loading_weight NUMERIC,
    p_calculation_method TEXT,
    p_tax_rate NUMERIC,
    p_profit_rate NUMERIC
)
RETURNS NUMERIC AS $$
DECLARE
    v_payable_amount NUMERIC;
BEGIN
    IF p_calculation_method = 'profit' THEN
        -- 利润法
        IF p_loading_weight IS NOT NULL AND p_loading_weight > 0 THEN
            v_payable_amount := p_base_amount + (p_profit_rate * p_loading_weight);
        ELSE
            v_payable_amount := p_base_amount + p_profit_rate;
        END IF;
    ELSE
        -- 税点法（默认）
        IF p_tax_rate IS NOT NULL AND p_tax_rate != 1 THEN
            v_payable_amount := p_base_amount / (1 - p_tax_rate);
        ELSE
            v_payable_amount := p_base_amount;
        END IF;
    END IF;
    
    RETURN v_payable_amount;
END;
$$ LANGUAGE plpgsql IMMUTABLE;
```

然后所有其他函数都调用这个核心函数：

```sql
-- 在各个重算函数中
v_payable_amount := calculate_partner_cost(
    v_base_amount,
    v_loading_weight,
    v_project_partners.calculation_method,
    v_project_partners.tax_rate,
    v_project_partners.profit_rate
);
```

---

## 📊 当前函数关系图

```
recalculate_costs_for_project
  └─> 循环调用 recalculate_costs_for_chain
        └─> [计算逻辑A]  ← 重复代码

recalculate_costs_for_chain_safe
  └─> [计算逻辑B]  ← 与A相同（重复）

modify_logistics_record_chain_with_recalc
  └─> [计算逻辑C]  ← 与A相同（重复）

batch_modify_chain
  └─> 循环调用 modify_logistics_record_chain_with_recalc
        └─> [计算逻辑C]
```

---

## 📊 重构后的函数关系图

```
                calculate_partner_cost (核心计算函数)
                           ↑
           ┌───────────────┼───────────────┐
           │               │               │
recalculate_costs    modify_logistics   其他函数...
_for_chain         _record_chain
                   _with_recalc
```

---

## ✅ 当前状态评估

### 优点

- ✅ 功能完整，各个场景都有对应函数
- ✅ 代码逻辑正确，计算准确
- ✅ 已经在生产环境使用

### 缺点（代码质量）

- ❌ **代码重复**：相同计算逻辑重复3次
- ❌ **维护成本高**：修改计算逻辑需要改3个地方
- ❌ **不符合DRY原则**（Don't Repeat Yourself）
- ❌ **容易出错**：修改一处忘记改另一处

---

## 🎯 影响评估

### 如果不重构

**风险**：
1. ⚠️ 修改计算逻辑时容易遗漏某个函数
2. ⚠️ 不同函数的计算逻辑可能不一致
3. ⚠️ 代码维护困难

**当前是否影响功能**：
- ✅ 不影响，功能正常工作
- ✅ 计算结果正确

### 如果重构

**优点**：
- ✅ 代码更清晰
- ✅ 只需维护一处计算逻辑
- ✅ 减少出错可能
- ✅ 更容易添加新的计算方法

**风险**：
- ⚠️ 需要修改多个函数
- ⚠️ 需要完整测试
- ⚠️ 可能引入新bug

---

## 💡 建议

### 短期（当前）

**保持现状**，原因：
1. ✅ 功能正常工作
2. ✅ 已在生产环境
3. ✅ 重构风险较大

**如果要修改计算逻辑**：
- ⚠️ 必须同步修改这3个函数
- ⚠️ 需要仔细对比确保一致

### 长期（未来优化）

**建议重构**：
1. 提取核心计算函数 `calculate_partner_cost`
2. 所有函数调用核心函数
3. 完整测试确保结果一致
4. 逐步迁移，降低风险

---

## 📝 函数对比详情

### 计算逻辑对比

| 函数 | 利润法逻辑 | 税点法逻辑 | 是否相同 |
|-----|-----------|-----------|---------|
| `recalculate_costs_for_chain` | base + (profit × weight) | base / (1 - tax) | 基准 |
| `recalculate_costs_for_chain_safe` | 同上 | 同上 | ✅ 相同 |
| `modify_logistics_record_chain_with_recalc` | 同上 | 同上 | ✅ 相同 |

### 附加功能对比

| 函数 | 权限检查 | 状态检查 | 批量处理 | 安全模式 |
|-----|---------|---------|---------|---------|
| `recalculate_costs_for_chain` | ❌ | ❌ | ✅ | ❌ |
| `recalculate_costs_for_chain_safe` | ❌ | ✅ | ✅ | ✅ |
| `modify_logistics_record_chain_with_recalc` | ✅ | ✅ | ❌ | ✅ |
| `batch_modify_chain` | ✅ | ❌ | ✅ | ✅ |

---

## 🚨 需要注意的地方

### 如果修改计算公式

**必须同步修改这些函数**：

1. ✅ `recalculate_costs_for_chain` (第68-83行)
2. ✅ `recalculate_costs_for_chain_safe` (相应位置)
3. ✅ `modify_logistics_record_chain_with_recalc` (第156-170行)

**验证清单**：
- [ ] 3个函数的计算逻辑完全一致
- [ ] 测试所有场景的重算结果
- [ ] 对比手动计算验证准确性

---

## 🎯 总结

### 问题确认

✅ **是的，您发现的问题确实存在！**

- ❌ 不是"同一个函数"
- ❌ 而是"相同的代码重复了3次"
- ⚠️ 存在代码重复和维护风险

### 当前状态

- ✅ 功能正常工作
- ✅ 计算结果正确
- ⚠️ 代码质量有提升空间

### 建议

**短期**：保持现状，注意同步修改  
**长期**：重构为核心计算函数

---

**是否需要我创建重构方案？**

