# 成本重算跳过手动修改的最高级合作方方案

## 🎯 业务需求

**核心需求**：

> 如果用户手动修改了最高级合作方的应收金额，  
> 后续的成本重算（如修改合作链路）应该**跳过**该合作方，  
> **保留用户的手动修改值**，不要被系统重算覆盖。

---

## 📋 问题场景

### 场景1：修改合作链路导致覆盖

```
1. 用户手动修改最高级合作方应收：1000元 → 1200元（谈好的实际价格）
2. 用户修改运单的合作链路
3. 系统触发成本重算
4. ❌ 最高级合作方应收被重算回 1000元
5. 😡 用户的手动修改丢失了！
```

### 场景2：批量修改链路导致覆盖

```
1. 100条运单，用户逐个谈好价格，手动修改了应收
2. 用户批量修改这些运单的合作链路
3. ❌ 所有手动修改的价格全部被重算覆盖
4. 😡 用户需要重新修改100次！
```

---

## 💡 解决方案

### 方案设计

#### 核心思路

1. **标记手动修改**
   - 在 `logistics_partner_costs` 表添加标记字段
   - 用户修改时设置标记为 true

2. **重算时跳过**
   - 所有成本重算函数检查标记
   - 如果是手动修改的，保留原值，不重新计算

3. **只保护最高级**
   - 只有最高级合作方才需要保护
   - 其他层级仍然自动计算

---

## 🔧 技术实现

### 步骤1：添加标记字段

```sql
-- 为 logistics_partner_costs 表添加手动修改标记字段
ALTER TABLE public.logistics_partner_costs 
ADD COLUMN IF NOT EXISTS is_manually_modified BOOLEAN DEFAULT FALSE;

-- 添加字段说明
COMMENT ON COLUMN public.logistics_partner_costs.is_manually_modified IS 
'标记该成本是否被手动修改过。如果为true，成本重算时将跳过此记录，保留用户的手动修改值';

-- 创建索引（用于快速查询手动修改的记录）
CREATE INDEX IF NOT EXISTS idx_logistics_partner_costs_manual_modified 
ON public.logistics_partner_costs(logistics_record_id, is_manually_modified) 
WHERE is_manually_modified = TRUE;
```

---

### 步骤2：修改用户修改应收的逻辑

#### 在 PaymentRequest.tsx 的 handleSavePartnerCost 函数中

**修改前**：
```typescript
const { error: updateError } = await supabase
  .from('logistics_partner_costs')
  .update({
    payable_amount: highestLevelPartner.payable_amount,
    updated_at: new Date().toISOString()
  })
  .eq('logistics_record_id', editPartnerCostData.recordId)
  .eq('partner_id', highestLevelPartner.partner_id)
  .eq('level', maxLevel);
```

**修改后**：
```typescript
const { error: updateError } = await supabase
  .from('logistics_partner_costs')
  .update({
    payable_amount: highestLevelPartner.payable_amount,
    is_manually_modified: true,  // 🆕 标记为手动修改
    updated_at: new Date().toISOString()
  })
  .eq('logistics_record_id', editPartnerCostData.recordId)
  .eq('partner_id', highestLevelPartner.partner_id)
  .eq('level', maxLevel);
```

---

### 步骤3：修改所有成本重算函数

#### 修改模式（所有3个函数都需要）

**原逻辑**：
```sql
-- 第一步：删除该运单的旧成本记录
DELETE FROM public.logistics_partner_costs
WHERE logistics_record_id = p_record_id;

-- 第二步：重新计算并插入所有合作方成本
FOR v_project_partners IN ... LOOP
    -- 计算金额
    v_payable_amount := ...;
    
    -- 插入新记录
    INSERT INTO logistics_partner_costs (...) VALUES (...);
END LOOP;
```

**新逻辑**：
```sql
-- 第一步：保存手动修改的最高级合作方成本（如果有）
DECLARE
    v_manual_modified_costs RECORD;
BEGIN
    -- 查找手动修改的最高级合作方记录
    SELECT 
        partner_id,
        level,
        payable_amount,
        base_amount,
        tax_rate
    INTO v_manual_modified_costs
    FROM public.logistics_partner_costs
    WHERE logistics_record_id = p_record_id
      AND is_manually_modified = TRUE
    ORDER BY level DESC  -- 最高级
    LIMIT 1;
    
    -- 第二步：删除旧成本记录
    DELETE FROM public.logistics_partner_costs
    WHERE logistics_record_id = p_record_id;
    
    -- 第三步：重新计算并插入
    FOR v_project_partners IN ... LOOP
        -- 🔍 检查是否是手动修改的最高级合作方
        IF v_manual_modified_costs IS NOT NULL 
           AND v_project_partners.partner_id = v_manual_modified_costs.partner_id 
           AND v_project_partners.level = v_manual_modified_costs.level THEN
            -- ✅ 保留手动修改的值
            v_payable_amount := v_manual_modified_costs.payable_amount;
            v_is_manual := TRUE;
        ELSE
            -- ❌ 系统自动计算
            v_payable_amount := calculate_cost(...);
            v_is_manual := FALSE;
        END IF;
        
        INSERT INTO logistics_partner_costs (
            ...,
            payable_amount,
            is_manually_modified  -- 🆕 保留标记
        ) VALUES (
            ...,
            v_payable_amount,
            v_is_manual
        );
    END LOOP;
END;
```

---

## 📊 修改影响范围

### 需要修改的数据库对象

| 类型 | 名称 | 修改内容 |
|-----|------|---------|
| 表字段 | `logistics_partner_costs.is_manually_modified` | 🆕 新增字段 |
| 函数 | `recalculate_costs_for_chain` | 修改重算逻辑 |
| 函数 | `recalculate_costs_for_chain_safe` | 修改重算逻辑 |
| 函数 | `modify_logistics_record_chain_with_recalc` | 修改重算逻辑 |

### 需要修改的前端代码

| 文件 | 函数 | 修改内容 |
|-----|------|---------|
| `src/pages/PaymentRequest.tsx` | `handleSavePartnerCost` | 添加 `is_manually_modified: true` |
| `src/pages/PaymentRequest.tsx` | `handleBatchModifyCost` | 添加 `is_manually_modified: true` |

---

## 🎨 用户体验流程

### 修改后的流程

```
1. 用户修改最高级合作方应收
   ↓
2. 系统标记：is_manually_modified = TRUE
   ↓
3. 用户修改合作链路
   ↓
4. 系统触发成本重算
   ↓
5. 检测到最高级合作方被手动修改
   ↓
6. ✅ 跳过重算，保留手动修改的 1200元
   ↓
7. ✅ 只重算其他层级的合作方成本
   ↓
8. 😊 用户的修改被保留了！
```

---

## 📝 详细实现

### SQL脚本：添加字段和修改函数

```sql
-- ============================================================================
-- 成本重算跳过手动修改方案
-- ============================================================================

BEGIN;

-- ============================================================================
-- 步骤1：添加手动修改标记字段
-- ============================================================================

ALTER TABLE public.logistics_partner_costs 
ADD COLUMN IF NOT EXISTS is_manually_modified BOOLEAN DEFAULT FALSE;

COMMENT ON COLUMN public.logistics_partner_costs.is_manually_modified IS 
'标记该成本是否被用户手动修改。TRUE=手动修改，重算时保留；FALSE=系统计算，可以重算';

CREATE INDEX IF NOT EXISTS idx_logistics_partner_costs_manual_modified 
ON public.logistics_partner_costs(logistics_record_id, is_manually_modified) 
WHERE is_manually_modified = TRUE;

-- ============================================================================
-- 步骤2：修改 modify_logistics_record_chain_with_recalc 函数
-- ============================================================================

CREATE OR REPLACE FUNCTION public.modify_logistics_record_chain_with_recalc(
    p_record_id UUID,
    p_chain_name TEXT
)
RETURNS JSON AS $$
DECLARE
    v_result JSON;
    v_can_access BOOLEAN;
    v_project_id UUID;
    v_chain_id UUID;
    v_old_chain_name TEXT;
    v_payment_status TEXT;
    v_invoice_status TEXT;
    v_project_partners RECORD;
    v_base_amount NUMERIC;
    v_payable_amount NUMERIC;
    v_loading_weight NUMERIC;
    v_unloading_weight NUMERIC;
    v_inserted_count INTEGER := 0;
    -- 🆕 保存手动修改的成本
    v_manual_partner_id UUID;
    v_manual_level INTEGER;
    v_manual_amount NUMERIC;
    v_has_manual_modified BOOLEAN := FALSE;
BEGIN
    -- [权限检查和状态检查的代码保持不变...]
    
    -- 🆕 第一步：检查是否有手动修改的成本（最高级合作方）
    SELECT 
        partner_id,
        level,
        payable_amount
    INTO v_manual_partner_id, v_manual_level, v_manual_amount
    FROM public.logistics_partner_costs
    WHERE logistics_record_id = p_record_id
      AND is_manually_modified = TRUE
    ORDER BY level DESC
    LIMIT 1;
    
    IF v_manual_partner_id IS NOT NULL THEN
        v_has_manual_modified := TRUE;
        RAISE NOTICE '检测到手动修改的成本记录：合作方 %, 级别 %, 金额 %', 
                     v_manual_partner_id, v_manual_level, v_manual_amount;
    END IF;
    
    -- 第二步：删除该运单的旧成本记录
    DELETE FROM public.logistics_partner_costs
    WHERE logistics_record_id = p_record_id;
    
    -- 第三步：更新运单的链路信息
    UPDATE public.logistics_records
    SET chain_id = v_chain_id, updated_at = NOW()
    WHERE id = p_record_id;
    
    -- 第四步：根据新链路重新计算并插入合作方成本
    FOR v_project_partners IN
        SELECT pp.partner_id, pp.level, pp.calculation_method, pp.tax_rate, pp.profit_rate
        FROM public.project_partners pp
        WHERE pp.project_id = v_project_id AND pp.chain_id = v_chain_id
        ORDER BY pp.level ASC
    LOOP
        -- 🔍 检查是否是手动修改的最高级合作方
        IF v_has_manual_modified 
           AND v_project_partners.partner_id = v_manual_partner_id 
           AND v_project_partners.level = v_manual_level THEN
            -- ✅ 保留用户手动修改的值
            v_payable_amount := v_manual_amount;
            
            INSERT INTO public.logistics_partner_costs (
                logistics_record_id, partner_id, level,
                base_amount, payable_amount, tax_rate,
                is_manually_modified,  -- 🆕 保留标记
                user_id
            ) VALUES (
                p_record_id, v_project_partners.partner_id, v_project_partners.level,
                v_base_amount, v_payable_amount, v_project_partners.tax_rate,
                TRUE,  -- 🆕 标记为手动修改
                auth.uid()
            );
            
            RAISE NOTICE '✅ 保留手动修改的最高级合作方成本：%', v_payable_amount;
        ELSE
            -- ❌ 系统自动计算其他层级
            IF v_project_partners.calculation_method = 'profit' THEN
                IF v_loading_weight IS NOT NULL AND v_loading_weight > 0 THEN
                    v_payable_amount := v_base_amount + (COALESCE(v_project_partners.profit_rate, 0) * v_loading_weight);
                ELSE
                    v_payable_amount := v_base_amount + COALESCE(v_project_partners.profit_rate, 0);
                END IF;
            ELSE
                IF v_project_partners.tax_rate IS NOT NULL AND v_project_partners.tax_rate != 1 THEN
                    v_payable_amount := v_base_amount / (1 - v_project_partners.tax_rate);
                ELSE
                    v_payable_amount := v_base_amount;
                END IF;
            END IF;
            
            INSERT INTO public.logistics_partner_costs (
                logistics_record_id, partner_id, level,
                base_amount, payable_amount, tax_rate,
                is_manually_modified,  -- 🆕 系统计算标记为false
                user_id
            ) VALUES (
                p_record_id, v_project_partners.partner_id, v_project_partners.level,
                v_base_amount, v_payable_amount, v_project_partners.tax_rate,
                FALSE,  -- 系统计算
                auth.uid()
            );
        END IF;
        
        v_inserted_count := v_inserted_count + 1;
    END LOOP;
    
    -- 返回结果（包含保护信息）
    RETURN json_build_object(
        'success', true,
        'message', CASE 
            WHEN v_has_manual_modified THEN '合作链路修改成功，已保护您手动修改的最高级合作方成本'
            ELSE '合作链路修改成功，已重新计算成本'
        END,
        'record_id', p_record_id,
        'old_chain_name', v_old_chain_name,
        'new_chain_name', p_chain_name,
        'recalculated_partners', v_inserted_count,
        'manual_modified_protected', v_has_manual_modified  -- 🆕 标记是否保护了手动修改
    );
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;
```

---

### 步骤2：修改前端保存逻辑

#### src/pages/PaymentRequest.tsx - handleSavePartnerCost

**修改第469-474行**：

```typescript
// 只更新最高级合作方的金额
const { error: updateError } = await supabase
  .from('logistics_partner_costs')
  .update({
    payable_amount: highestLevelPartner.payable_amount,
    is_manually_modified: true,  // 🆕 标记为手动修改
    updated_at: new Date().toISOString()
  })
  .eq('logistics_record_id', editPartnerCostData.recordId)
  .eq('partner_id', highestLevelPartner.partner_id)
  .eq('level', maxLevel);
```

#### src/pages/PaymentRequest.tsx - handleBatchModifyCost

**修改第585-593行**：

```typescript
// 更新最高级合作方的金额
const { error: updateError } = await supabase
  .from('logistics_partner_costs')
  .update({
    payable_amount: newAmount,
    is_manually_modified: true,  // 🆕 标记为手动修改
    updated_at: new Date().toISOString()
  })
  .eq('logistics_record_id', record.id)
  .eq('partner_id', highestPartner.partner_id)
  .eq('level', highestPartner.level);
```

---

## 🎯 保护逻辑详解

### 重算时的判断流程

```
开始重算运单成本
  ↓
检查是否有手动修改的成本记录
  ↓
有手动修改？
  ├─ 是 → 保存手动修改的 partner_id, level, amount
  └─ 否 → 正常重算所有合作方
  ↓
删除旧的成本记录
  ↓
遍历新链路的所有合作方
  ↓
对每个合作方：
  ├─ 是手动修改的最高级合作方？
  │   ├─ 是 → ✅ 使用保存的手动金额
  │   │       ✅ is_manually_modified = TRUE
  │   └─ 否 → ❌ 系统自动计算
  │           ❌ is_manually_modified = FALSE
  ↓
插入新的成本记录
  ↓
完成
```

---

## ✨ 功能亮点

### 1. 只保护最高级合作方

```
合作链路：可乐 (1级) → 雪碧 (2级) → 芬达 (3级)

用户修改了芬达(3级)的应收：1000 → 1200
系统标记：芬达 is_manually_modified = TRUE

后续重算时：
- 可乐 (1级)：系统重新计算 ✅
- 雪碧 (2级)：系统重新计算 ✅
- 芬达 (3级)：保留 1200 ✅（用户手动值）
```

### 2. 智能提示用户

```typescript
toast({ 
  title: "成功", 
  description: `合作链路已更新，已保护您手动修改的最高级合作方成本` 
});
```

### 3. 可以重置为系统计算

如果用户想恢复为系统自动计算：

```typescript
// 提供"重置为自动计算"按钮
const resetToAutoCalculation = async () => {
  await supabase
    .from('logistics_partner_costs')
    .update({ is_manually_modified: false })
    .eq('logistics_record_id', recordId)
    .eq('level', maxLevel);
  
  // 触发重新计算
  // ...
};
```

---

## 🧪 测试场景

### 测试1：手动修改后修改链路

```
1. 运单使用链路A（可乐→雪碧→芬达）
2. 用户手动修改芬达应收：1000 → 1200
3. 用户修改链路为链路B
4. 验证：芬达应收仍然是 1200 ✅
5. 验证：其他合作方按链路B重新计算 ✅
```

### 测试2：批量修改后批量改链路

```
1. 100条运单，手动修改了最高级应收
2. 批量修改这些运单的链路
3. 验证：所有手动修改的值都保留 ✅
4. 验证：其他层级重新计算 ✅
```

### 测试3：未手动修改的正常重算

```
1. 运单没有手动修改过应收
2. 修改合作链路
3. 验证：所有合作方都重新计算 ✅
4. 验证：is_manually_modified 都是 FALSE ✅
```

---

## ⚠️ 注意事项

### 1. 链路中的合作方变化

**问题**：如果新链路的最高级合作方变了怎么办？

**场景**：
```
链路A：可乐(1) → 雪碧(2) → 芬达(3)  ← 手动修改了芬达
链路B：可乐(1) → 雪碧(2) → 美年达(3) ← 最高级变成美年达了
```

**解决**：
- 通过 `partner_id` 匹配
- 如果新链路没有这个 partner_id，自然就不会保留
- 只有新链路中仍然存在的合作方才会保留手动值

### 2. 级别变化

**场景**：
```
链路A：芬达是3级
链路B：芬达变成2级了
```

**解决**：
- 同时匹配 `partner_id` 和 `level`
- 级别变了就视为不同的配置，重新计算

### 3. 清除手动修改标记

如果用户想重新计算，需要先清除标记：

```sql
-- 清除某条运单的手动修改标记
UPDATE logistics_partner_costs
SET is_manually_modified = FALSE
WHERE logistics_record_id = '运单ID';
```

---

## 📋 完整实施清单

### 数据库修改
- [ ] 添加 `is_manually_modified` 字段
- [ ] 添加索引
- [ ] 修改 `modify_logistics_record_chain_with_recalc` 函数
- [ ] 修改 `recalculate_costs_for_chain` 函数
- [ ] 修改 `recalculate_costs_for_chain_safe` 函数

### 前端修改
- [ ] 修改 `handleSavePartnerCost` 函数
- [ ] 修改 `handleBatchModifyCost` 函数
- [ ] 添加成功提示（告知已保护手动修改）

### 测试
- [ ] 测试手动修改后改链路
- [ ] 测试批量修改场景
- [ ] 测试未手动修改的正常重算
- [ ] 测试链路中合作方变化的情况

---

## 🎯 立即执行还是评估？

**需要我立即创建完整的SQL脚本和前端修改代码吗？**

这个功能非常重要，建议尽快实施！ 🚀

