# 成本重算跳过逻辑完整分析

## 📊 跳过逻辑总览

系统中的成本重算函数包含**4种跳过逻辑**：

| 序号 | 跳过逻辑 | 保护对象 | 应用函数 | 级别 |
|-----|---------|---------|---------|------|
| 1 | 跳过已付款运单 | 整条运单 | recalculate_costs_for_chain_safe | 运单级 |
| 2 | 跳过已开票运单 | 整条运单 | modify_logistics_record_chain_with_recalc | 运单级 |
| 3 | 跳过手动修改的合作方 | 特定合作方成本 | 所有重算函数（新增） | 成本记录级 |
| 4 | 条件判断不需要重算 | 避免无效操作 | 触发器函数 | 操作级 |

---

## 🔍 详细分析

### 跳过逻辑1️⃣：跳过已付款运单

#### 应用函数
- `recalculate_costs_for_chain_safe`

#### 跳过条件
```sql
-- 检查是否有已付款的成本记录
SELECT EXISTS (
    SELECT 1 FROM logistics_partner_costs
    WHERE logistics_record_id = v_record_id
      AND payment_status = 'Paid'
) INTO v_has_paid_status;

-- 如果是安全模式且有已付款记录，跳过
IF p_only_unpaid AND v_has_paid_status THEN
    v_skipped_count := v_skipped_count + 1;
    CONTINUE;  -- 跳过这条运单
END IF;
```

#### 保护级别
- **运单级**：整条运单的所有合作方成本都不重算

#### 保护范围
- ✅ 该运单的所有合作方成本
- ✅ 1级、2级、3级...所有层级

#### 使用场景
- 修改项目合作方配置时
- 手动调用重算函数时
- 参数 `p_only_unpaid = TRUE`

#### 统计信息
```json
{
  "total_records": 100,
  "updated_records": 80,
  "skipped_records": 20,  // 跳过的已付款运单
  "message": "总计 100 条运单，更新 80 条，跳过 20 条（已付款）"
}
```

---

### 跳过逻辑2️⃣：跳过已开票运单

#### 应用函数
- `modify_logistics_record_chain_with_recalc`

#### 跳过条件
```sql
-- 检查开票状态
IF v_invoice_status IS NOT NULL AND v_invoice_status != 'Uninvoiced' THEN
    RETURN json_build_object(
        'success', false,
        'message', '只有未开票状态的运单才能修改合作链路。当前开票状态：' || 
            CASE 
                WHEN v_invoice_status = 'Processing' THEN '开票中'
                WHEN v_invoice_status = 'Invoiced' THEN '已开票'
                ELSE v_invoice_status
            END
    );
END IF;
```

#### 保护级别
- **运单级**：整条运单不允许修改链路

#### 保护范围
- ✅ 已开票运单完全不能修改链路
- ✅ 所有成本保持不变

#### 触发条件
- `invoice_status = 'Processing'` （开票中）
- `invoice_status = 'Invoiced'` （已开票）

#### 用户提示
```
❌ 只有未开票状态的运单才能修改合作链路。当前开票状态：已开票
```

---

### 跳过逻辑3️⃣：跳过已支付运单

#### 应用函数
- `modify_logistics_record_chain_with_recalc`

#### 跳过条件
```sql
-- 检查支付状态
IF v_payment_status != 'Unpaid' THEN
    RETURN json_build_object(
        'success', false,
        'message', '只有未支付状态的运单才能修改合作链路。当前付款状态：' || 
            CASE 
                WHEN v_payment_status = 'Processing' THEN '已申请支付'
                WHEN v_payment_status = 'Paid' THEN '已完成支付'
                ELSE v_payment_status
            END
    );
END IF;
```

#### 保护级别
- **运单级**：整条运单不允许修改链路

#### 保护范围
- ✅ 已申请支付的运单不能修改
- ✅ 已完成支付的运单不能修改

#### 触发条件
- `payment_status = 'Processing'` （已申请支付）
- `payment_status = 'Paid'` （已完成支付）

#### 用户提示
```
❌ 只有未支付状态的运单才能修改合作链路。当前付款状态：已申请支付
```

---

### 跳过逻辑4️⃣：跳过手动修改的合作方（🆕 新增）

#### 应用函数
- `modify_logistics_record_chain_with_recalc`（已实施）
- `recalculate_costs_for_chain`（已实施）
- `recalculate_costs_for_chain_safe`（已实施）

#### 跳过条件
```sql
-- 重算前：保存手动修改的最高级合作方
SELECT partner_id, level, payable_amount
INTO v_manual_partner_id, v_manual_level, v_manual_amount
FROM logistics_partner_costs
WHERE logistics_record_id = v_record_id
  AND is_manually_modified = TRUE
ORDER BY level DESC
LIMIT 1;

-- 重算时：检查是否是手动修改的合作方
IF v_has_manual_modified 
   AND v_project_partners.partner_id = v_manual_partner_id 
   AND v_project_partners.level = v_manual_level THEN
    -- ✅ 保留手动修改的值
    v_payable_amount := v_manual_amount;
    is_manually_modified := TRUE;
ELSE
    -- ❌ 系统自动计算
    v_payable_amount := 系统计算(...);
    is_manually_modified := FALSE;
END IF;
```

#### 保护级别
- **成本记录级**：只保护特定的合作方成本记录

#### 保护范围
- ✅ 只保护手动修改的最高级合作方
- ❌ 其他层级仍然重算

#### 触发标记
- 用户在前端修改应收时，`is_manually_modified` 被设为 `TRUE`

#### 用户提示
```
✅ 合作链路修改成功，已保护您手动修改的最高级合作方成本
```

---

### 跳过逻辑5️⃣：条件判断不需要重算

#### 应用函数
- `auto_recalc_on_project_partner_change`（触发器函数）

#### 跳过条件
```sql
-- 判断是否需要重新计算
IF TG_OP = 'UPDATE' THEN
    -- 只在关键字段变化时才重算
    IF OLD.partner_id IS DISTINCT FROM NEW.partner_id OR
       OLD.level IS DISTINCT FROM NEW.level OR
       OLD.tax_rate IS DISTINCT FROM NEW.tax_rate OR
       OLD.calculation_method IS DISTINCT FROM NEW.calculation_method OR
       OLD.profit_rate IS DISTINCT FROM NEW.profit_rate THEN
        v_should_recalc := TRUE;
    ELSE
        v_should_recalc := FALSE;  -- 不需要重算
    END IF;
END IF;

-- 不需要重算时直接返回
IF NOT v_should_recalc THEN
    RETURN NEW;
END IF;
```

#### 保护级别
- **操作级**：避免不必要的重算操作

#### 保护对象
- 只更新了非关键字段时（如 created_at、user_id 等）
- 避免无意义的重算

#### 跳过的字段更新
- `user_id` 变化 → 不重算
- `created_at` 变化 → 不重算
- 其他非计算相关字段 → 不重算

---

## 📊 跳过逻辑对比表

| 跳过逻辑 | 检查对象 | 检查字段 | 跳过级别 | 是否可配置 | 跳过后操作 |
|---------|---------|---------|---------|----------|----------|
| 1. 已付款运单 | 运单 | payment_status='Paid' | 整条运单 | ✅ p_only_unpaid | CONTINUE |
| 2. 已开票运单 | 运单 | invoice_status≠'Uninvoiced' | 整条运单 | ❌ 强制 | RETURN error |
| 3. 已申请支付运单 | 运单 | payment_status≠'Unpaid' | 整条运单 | ❌ 强制 | RETURN error |
| 4. 手动修改合作方 | 成本记录 | is_manually_modified=TRUE | 特定记录 | ❌ 自动 | 保留原值 |
| 5. 非关键字段更新 | 操作 | 字段对比 | 整个操作 | ❌ 自动 | RETURN |

---

## 🎯 不同函数的跳过逻辑组合

### recalculate_costs_for_chain

**跳过逻辑**：
- ✅ 4️⃣ 跳过手动修改的合作方（新增）

**不跳过**：
- ❌ 1️⃣ 不跳过已付款运单（会重算所有运单）
- ❌ 2️⃣ 不检查开票状态
- ❌ 3️⃣ 不检查支付状态

**特点**：**强制重算**，只保护手动修改的成本

---

### recalculate_costs_for_chain_safe

**跳过逻辑**：
- ✅ 1️⃣ 跳过已付款运单（可配置）
- ✅ 4️⃣ 跳过手动修改的合作方（新增）

**不跳过**：
- ❌ 2️⃣ 不检查开票状态
- ❌ 3️⃣ 不检查支付状态（只检查已付款，不检查申请中）

**特点**：**安全重算**，双重保护

---

### modify_logistics_record_chain_with_recalc

**跳过逻辑**：
- ✅ 2️⃣ 拒绝已开票运单
- ✅ 3️⃣ 拒绝已支付/申请支付运单
- ✅ 4️⃣ 跳过手动修改的合作方（新增）

**特点**：**最严格**，三重保护

---

### auto_recalc_on_project_partner_change（触发器）

**跳过逻辑**：
- ✅ 5️⃣ 非关键字段更新不触发
- ✅ 调用 `recalculate_costs_for_chain_safe`（包含1️⃣和4️⃣）

**特点**：**智能触发** + 安全重算

---

## 📋 详细逻辑流程图

### modify_logistics_record_chain_with_recalc（3层保护）

```
开始修改链路
    ↓
检查1: payment_status = 'Unpaid' ?
    ├─ 否 → ❌ 返回错误（跳过逻辑3️⃣）
    └─ 是 → 继续
    ↓
检查2: invoice_status = 'Uninvoiced' ?
    ├─ 否 → ❌ 返回错误（跳过逻辑2️⃣）
    └─ 是 → 继续
    ↓
检查3: 是否有手动修改的成本 ?
    ├─ 有 → 保存(partner_id, level, amount)
    └─ 无 → 不保存
    ↓
删除旧成本记录
    ↓
遍历新链路的合作方
    ↓
对每个合作方：
    检查4: 是手动修改的最高级合作方?
        ├─ 是 → ✅ 使用保存的手动值（跳过逻辑4️⃣）
        │         is_manually_modified = TRUE
        └─ 否 → ❌ 系统自动计算
                  is_manually_modified = FALSE
    ↓
插入新成本记录
    ↓
完成
```

---

### recalculate_costs_for_chain_safe（2层保护）

```
开始重算链路
    ↓
遍历该链路的所有运单
    ↓
对每条运单：
    检查1: 有已付款的成本记录?
        ├─ 有 且 p_only_unpaid=TRUE → ⏭️ CONTINUE（跳过逻辑1️⃣）
        └─ 否 → 继续
        ↓
    检查2: 是否有手动修改的成本?
        ├─ 有 → 保存(partner_id, level, amount)
        └─ 无 → 不保存
        ↓
    删除旧成本记录
        ↓
    遍历合作方：
        检查3: 是手动修改的最高级合作方?
            ├─ 是 → ✅ 保留手动值（跳过逻辑4️⃣）
            └─ 否 → ❌ 系统计算
        ↓
    插入新成本记录
    ↓
下一条运单
```

---

### recalculate_costs_for_chain（1层保护）

```
开始重算链路
    ↓
遍历该链路的所有运单（包括已付款）
    ↓
对每条运单：
    检查1: 是否有手动修改的成本?
        ├─ 有 → 保存(partner_id, level, amount)
        └─ 无 → 不保存
        ↓
    删除旧成本记录
        ↓
    遍历合作方：
        检查2: 是手动修改的最高级合作方?
            ├─ 是 → ✅ 保留手动值（跳过逻辑4️⃣）
            └─ 否 → ❌ 系统计算
        ↓
    插入新成本记录
    ↓
下一条运单
```

---

### auto_recalc_on_project_partner_change（智能触发）

```
project_partners 表发生变化
    ↓
触发器被调用
    ↓
检查1: 操作类型?
    ├─ DELETE → 需要重算
    ├─ INSERT → 需要重算
    └─ UPDATE → 检查关键字段
        ↓
        检查2: 关键字段变化?
            ├─ partner_id 变化 → 需要重算
            ├─ level 变化 → 需要重算
            ├─ tax_rate 变化 → 需要重算
            ├─ calculation_method 变化 → 需要重算
            ├─ profit_rate 变化 → 需要重算
            └─ 其他字段变化 → ⏭️ 不重算（跳过逻辑5️⃣）
    ↓
调用 recalculate_costs_for_chain_safe(..., TRUE)
    （包含跳过逻辑1️⃣和4️⃣）
```

---

## 🛡️ 保护层级对比

### 运单级保护（粗粒度）

**跳过整条运单**：
- 1️⃣ 已付款运单
- 2️⃣ 已开票运单
- 3️⃣ 已申请支付运单

**影响**：
- ✅ 该运单的所有合作方成本都不重算
- ✅ 保护范围大

**示例**：
```
运单X 已付款
├─ 可乐(1级) → 不重算 ✅
├─ 雪碧(2级) → 不重算 ✅
└─ 芬达(3级) → 不重算 ✅
```

---

### 成本记录级保护（细粒度）

**只跳过特定成本记录**：
- 4️⃣ 手动修改的最高级合作方

**影响**：
- ✅ 只保护手动修改的那一条成本记录
- ✅ 其他层级仍然重算

**示例**：
```
运单X 未付款，芬达(3级)被手动修改
├─ 可乐(1级) → 系统重算 ✅
├─ 雪碧(2级) → 系统重算 ✅
└─ 芬达(3级) → 保留手动值 ✅
```

---

## 📊 跳过逻辑优先级

### 优先级从高到低

```
1. 最高优先级：运单状态检查（2️⃣ 3️⃣）
   ↓ 如果运单已开票或已支付，直接拒绝，不执行任何操作
   
2. 次优先级：运单级跳过（1️⃣）
   ↓ 如果运单已付款，跳过整条运单
   
3. 细粒度保护：成本记录级跳过（4️⃣）
   ↓ 在重算过程中，保护手动修改的记录
   
4. 最低优先级：智能触发（5️⃣）
   ↓ 根据字段变化决定是否需要重算
```

---

## 💡 实际应用场景

### 场景1：用户修改链路（单个）

**函数**：`modify_logistics_record_chain_with_recalc`

**跳过逻辑应用**：
1. ✅ 检查支付状态（3️⃣）→ 已支付/申请中 → 拒绝
2. ✅ 检查开票状态（2️⃣）→ 已开票/开票中 → 拒绝
3. ✅ 保护手动修改（4️⃣）→ 保留手动值 → 继续

**结果**：
- 只有"未支付"且"未开票"的运单可以修改
- 手动修改的最高级合作方成本被保护

---

### 场景2：修改项目配置（触发器）

**函数**：`auto_recalc_on_project_partner_change` → 调用 `recalculate_costs_for_chain_safe`

**跳过逻辑应用**：
1. ✅ 智能触发（5️⃣）→ 非关键字段 → 不触发
2. ✅ 跳过已付款（1️⃣）→ 已付款运单 → 跳过
3. ✅ 保护手动修改（4️⃣）→ 保留手动值 → 继续

**结果**：
- 只有关键字段变化才触发
- 只重算未付款运单
- 保护手动修改的成本

---

### 场景3：强制重算整个链路

**函数**：`recalculate_costs_for_chain`

**跳过逻辑应用**：
1. ✅ 保护手动修改（4️⃣）→ 保留手动值 → 继续
2. ❌ 不跳过已付款运单 → **会重算所有运单**

**结果**：
- ⚠️ 危险操作：包括已付款运单都会重算
- ✅ 但仍然保护手动修改的成本

---

## ⚠️ 注意事项

### 1. 跳过逻辑的层次性

```
运单级保护（外层）
    ├─ 已付款 → 整条运单跳过
    ├─ 已开票 → 整条运单拒绝
    └─ 已申请支付 → 整条运单拒绝

成本记录级保护（内层）
    └─ 手动修改 → 只保护该记录，其他照常
```

### 2. 跳过 vs 拒绝

| 处理方式 | 说明 | 返回 | 用户感知 |
|---------|------|------|---------|
| **跳过（CONTINUE）** | 跳过这条，继续下一条 | 成功（跳过N条） | 批量操作部分成功 |
| **拒绝（RETURN error）** | 直接拒绝操作 | 失败（错误信息） | 操作被阻止 |

### 3. 批量操作的影响

```
批量修改100条运单的链路：
- 20条已付款 → 拒绝修改（跳过逻辑3️⃣）
- 10条已开票 → 拒绝修改（跳过逻辑2️⃣）
- 70条可以修改
  - 其中30条有手动修改的成本 → 保留手动值（跳过逻辑4️⃣）
  - 其中40条无手动修改 → 完全重算

最终结果：
✅ 成功: 70条
❌ 失败: 30条（已付款/已开票）
```

---

## 📝 总结

### 跳过逻辑总数：5种

1. **已付款运单跳过**（运单级，可配置）
2. **已开票运单拒绝**（运单级，强制）
3. **已申请支付拒绝**（运单级，强制）
4. **手动修改保护**（记录级，自动）🆕
5. **智能触发判断**（操作级，自动）

### 保护层次

```
最外层：运单状态保护（1️⃣ 2️⃣ 3️⃣）
    ↓
中间层：操作优化（5️⃣）
    ↓
最内层：数据保护（4️⃣）
```

### 设计理念

- ✅ **多层防护**：从粗到细，层层保护
- ✅ **智能判断**：只在必要时重算
- ✅ **用户友好**：保护用户的手动修改

---

**跳过逻辑已经非常完善！** 🎯
