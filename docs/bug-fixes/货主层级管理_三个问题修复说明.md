# 货主层级管理 - 三个问题修复说明

## 📅 修复日期
2025-01-22

## 🐛 修复的问题

### 问题 1：取消根节点不生效 ❌ → ✅

**问题描述**：
- 点击"取消根节点"按钮后，货主仍然显示为根节点
- 触发器自动将 `parent_partner_id = NULL` 的节点设为 `is_root = TRUE`
- 用户设置的 `is_root = false` 被触发器覆盖

**根本原因**：
触发器逻辑太简单，总是用 `parent_partner_id IS NULL` 来判断是否为根节点：

```sql
-- 旧逻辑（有问题）
is_root_node := (NEW.parent_partner_id IS NULL);
NEW.is_root := is_root_node;  -- 总是覆盖用户设置
```

**解决方案**：

修改触发器逻辑，允许用户手动设置 `is_root = false`：

```sql
-- 新逻辑（已修复）
IF TG_OP = 'INSERT' OR OLD.is_root IS NULL OR NEW.is_root IS NULL THEN
  -- INSERT 或字段为空时，自动设置
  is_root_node := (NEW.parent_partner_id IS NULL);
  NEW.is_root := is_root_node;
ELSE
  -- UPDATE 时保留用户设置，除非改变了 parent_partner_id
  IF OLD.parent_partner_id IS DISTINCT FROM NEW.parent_partner_id THEN
    is_root_node := (NEW.parent_partner_id IS NULL);
    NEW.is_root := is_root_node;
  END IF;
  -- 否则保留 NEW.is_root（用户设置的值）
END IF;
```

**效果**：
- ✅ 用户可以手动设置 `is_root = false`
- ✅ 取消根节点功能正常工作
- ✅ 改变上下级关系时自动更新 `is_root`

---

### 问题 2：已在树中的子节点还显示在下面 ❌ → ✅

**问题描述**：
- 如图所示，"中粮"是"中粮集团"的子节点
- 但"中粮"还出现在"未设为根节点的货主"列表中
- 导致重复显示，容易混淆

**根本原因**：
筛选逻辑只检查 `!p.is_root`，没有检查是否已经在树中：

```typescript
// 旧逻辑（有问题）
const unassignedList = (data || []).filter((p: any) => !p.is_root);
// 这会包含所有非根节点，即使它们已经在树中作为子节点显示
```

**解决方案**：

递归标记所有在树中的节点，排除它们：

```typescript
// 新逻辑（已修复）
// 1. 构建树时记录所有在树中的节点ID
const inTreeIds = new Set<string>();

// 2. 递归标记所有在树中的节点
const markTreeNodes = (nodes: any[]) => {
  nodes.forEach(node => {
    inTreeIds.add(node.id);
    if (node.children && node.children.length > 0) {
      markTreeNodes(node.children);
    }
  });
};
markTreeNodes(roots);

// 3. 未分配列表只包含不在树中的节点
const unassignedList = (data || []).filter((p: any) => 
  !p.is_root && !inTreeIds.has(p.id)
);
```

**效果**：
- ✅ 已在树中显示的子节点不会出现在未分配列表
- ✅ 只有真正未分配的货主才显示在下面
- ✅ 避免重复显示，界面更清晰

**示例**：

修复前：
```
组织架构树：
└── 中粮集团（根）
    └── 中粮（子节点）      ← 在树中显示

未分配列表：
- 中粮                     ← 重复显示！❌
```

修复后：
```
组织架构树：
└── 中粮集团（根）
    └── 中粮（子节点）      ← 只在树中显示

未分配列表：
（空 - 中粮不会在这里显示）✅
```

---

### 问题 3：子节点无法断开上下级关系 ❌ → ✅

**问题描述**：
- 子节点只能拖拽到其他位置
- 无法直接断开与上级的关系
- 无法将子节点从树中移出

**根本原因**：
缺少断开上下级关系的功能

**解决方案**：

1. **添加"脱离上级"按钮**

```typescript
// 只对子节点且没有下级的显示
{canEdit && isChild && !hasChildren && (
  <Button 
    variant="ghost" 
    size="sm"
    onClick={() => onDetach(node.id, node.name, node.parent_name)}
    className="text-xs text-purple-600 hover:text-purple-700 hover:bg-purple-50"
  >
    脱离上级
  </Button>
)}
```

2. **添加脱离上级函数**

```typescript
const handleDetach = async (id: string, name: string, parentName: string) => {
  if (!confirm(`确定将 "${name}" 从 "${parentName}" 下脱离？\n\n脱离后该货主将移到"未分配"列表，需要重新设置层级。`)) 
    return;

  try {
    const { error } = await supabase
      .from('partners')
      .update({ 
        parent_partner_id: null,
        is_root: false 
      } as any)
      .eq('id', id);

    if (error) throw error;
    toast.success('已脱离上级');
    load();
  } catch (e: any) {
    toast.error('失败: ' + e.message);
  }
};
```

**效果**：
- ✅ 子节点可以点击"脱离上级"按钮
- ✅ 脱离后移到未分配列表
- ✅ 可以重新拖拽到其他位置或设为根节点

**使用限制**：
- 只有**没有下级**的子节点才能脱离
- 有下级的子节点需要先处理下级关系

---

## 🔧 额外修复：拖拽判断逻辑优化

**问题**：使用 `includes()` 判断可能误判UUID

**修复前**：
```typescript
if (target.hierarchy_path?.includes(dragId)) {
  // 可能误判：dragId是UUID的一部分时会误报
}
```

**修复后**：
```typescript
if (drag.hierarchy_path && target.hierarchy_path) {
  // 精确判断：target的路径是否以drag的路径开头
  if (target.hierarchy_path.startsWith(drag.hierarchy_path + '/') || 
      target.hierarchy_path === drag.hierarchy_path) {
    toast.error('不能拖到子孙节点下');
    return;
  }
}
```

**效果**：
- ✅ 精确判断层级关系
- ✅ 避免UUID部分匹配导致的误判
- ✅ 提示信息更友好

---

## 📝 修改的文件

### 1. 数据库迁移文件

**文件**：`supabase/migrations/20250122_update_hierarchy_to_owner_only.sql`

**修改**：触发器函数 `maintain_partner_hierarchy()`

**变更内容**：
- 允许用户手动设置 `is_root = false`
- 只在必要时自动设置 `is_root`
- UPDATE 时保留用户设置的值

### 2. 前端组件

**文件**：`src/pages/PartnerHierarchyManagement.tsx`

**修改内容**：

| 修改项 | 说明 |
|--------|------|
| TreeNode 组件 | 添加 `onDetach` 参数和"脱离上级"按钮 |
| load 函数 | 修改未分配列表筛选逻辑，排除树中节点 |
| handleDrop | 优化拖拽判断逻辑，使用精确的路径比较 |
| handleDetach | 新增脱离上级函数 |
| 绿色区域拖拽 | 修复设为根节点逻辑，设置 `is_root: true` |
| 界面文案 | 更新说明和提示文字 |

---

## 🎨 界面效果

### 根节点（没有下级）

```
┌────────────────────────────────────────┐
│ ≡  🏠 根  中粮集团         [取消根节点]  │
│          下级: 0                       │
└────────────────────────────────────────┘
```

**操作**：
- 点击"取消根节点" → 移到未分配列表

### 子节点（没有下级）

```
┌────────────────────────────────────────┐
│    ≡  L1  中粮                [脱离上级] │
│          上级: 中粮集团 | 下级: 0       │
└────────────────────────────────────────┘
```

**操作**：
- 点击"脱离上级" → 断开与中粮集团的关系 → 移到未分配列表

### 有下级的节点

```
┌────────────────────────────────────────┐
│ ▼  🏠 根  中粮集团                      │
│          下级: 2                       │
│    ┌─────────────────────────┐        │
│    │ L1  中粮贸易              │        │
│    └─────────────────────────┘        │
└────────────────────────────────────────┘
```

**操作**：
- 无"取消根节点"或"脱离上级"按钮
- 需要先处理下级关系

---

## 💡 操作逻辑

### 情况 1：取消根节点

**条件**：
- ✅ 是根节点
- ✅ 没有下级

**操作**：
```
中粮集团（根节点，无下级）
  ↓ 点击"取消根节点"
未分配列表中：中粮集团（独立）
```

**数据变化**：
```sql
parent_partner_id: NULL → NULL  (不变)
is_root: TRUE → FALSE           (改变)
```

### 情况 2：脱离上级

**条件**：
- ✅ 是子节点（有上级）
- ✅ 没有下级

**操作**：
```
中粮集团（根）
  └── 中粮（子节点，无下级）
        ↓ 点击"脱离上级"
未分配列表中：中粮（独立）
```

**数据变化**：
```sql
parent_partner_id: UUID → NULL  (清空上级)
is_root: FALSE → FALSE          (保持)
```

### 情况 3：拖拽调整

**始终可用**（无论是否有下级）

**操作**：
```
拖拽任意节点到目标位置
  ↓
建立新的上下级关系
```

---

## 🔍 技术实现

### 1. 触发器逻辑优化

**关键代码**：

```sql
-- 判断是否为根节点
IF TG_OP = 'INSERT' OR OLD.is_root IS NULL OR NEW.is_root IS NULL THEN
  -- 新插入或字段为空：自动设置
  is_root_node := (NEW.parent_partner_id IS NULL);
  NEW.is_root := is_root_node;
ELSE
  -- 更新时：只在改变了上级时自动设置，否则保留用户设置
  IF OLD.parent_partner_id IS DISTINCT FROM NEW.parent_partner_id THEN
    is_root_node := (NEW.parent_partner_id IS NULL);
    NEW.is_root := is_root_node;
  END IF;
  -- 否则保留 NEW.is_root
END IF;
```

**场景测试**：

| 操作 | parent_partner_id | is_root | 触发器行为 |
|------|------------------|---------|-----------|
| INSERT (无上级) | NULL | NULL | 自动设为 TRUE |
| INSERT (有上级) | UUID | NULL | 自动设为 FALSE |
| UPDATE (取消根节点) | NULL → NULL | TRUE → FALSE | **保留 FALSE** ✅ |
| UPDATE (脱离上级) | UUID → NULL | FALSE → FALSE | **保留 FALSE** ✅ |
| UPDATE (改变上级) | UUID1 → UUID2 | FALSE | 保持 FALSE |
| UPDATE (设为根节点) | NULL | FALSE → TRUE | 保留 TRUE |

### 2. 未分配列表逻辑优化

**关键代码**：

```typescript
// 1. 构建树时记录所有在树中的节点
const inTreeIds = new Set<string>();

// 2. 递归标记
const markTreeNodes = (nodes: any[]) => {
  nodes.forEach(node => {
    inTreeIds.add(node.id);  // 标记根节点
    if (node.children && node.children.length > 0) {
      markTreeNodes(node.children);  // 递归标记子节点
    }
  });
};
markTreeNodes(roots);

// 3. 筛选未分配
const unassignedList = (data || []).filter((p: any) => 
  !p.is_root &&           // 不是根节点
  !inTreeIds.has(p.id)    // 不在任何树中
);
```

**示例**：

```
数据库中的货主：
1. 中粮集团: is_root=TRUE, parent=NULL         → inTreeIds ✓
2. 中粮:     is_root=FALSE, parent=中粮集团    → inTreeIds ✓
3. 武汉方:   is_root=TRUE, parent=NULL         → inTreeIds ✓
4. 中粮:     is_root=FALSE, parent=NULL        → 不在 inTreeIds

未分配列表：
只有第4个"中粮"（独立的，不在树中）
```

### 3. 脱离上级功能

**关键代码**：

```typescript
// 组件新增按钮
{canEdit && isChild && !hasChildren && (
  <Button onClick={() => onDetach(node.id, node.name, node.parent_name)}>
    脱离上级
  </Button>
)}

// 处理函数
const handleDetach = async (id, name, parentName) => {
  await supabase.from('partners').update({ 
    parent_partner_id: null,  // 清空上级
    is_root: false            // 不设为根节点
  }).eq('id', id);
};
```

---

## ✅ 验证方法

### 验证问题1：取消根节点

```sql
-- 1. 找一个没有下级的根节点
SELECT id, name, is_root, parent_partner_id
FROM partners
WHERE partner_type = '货主' 
  AND is_root = TRUE
  AND NOT EXISTS (SELECT 1 FROM partners p2 WHERE p2.parent_partner_id = partners.id);

-- 2. 取消根节点（通过UI或SQL）
UPDATE partners 
SET parent_partner_id = NULL, is_root = FALSE 
WHERE id = '某根节点UUID';

-- 3. 验证 is_root 保持为 FALSE
SELECT id, name, is_root, parent_partner_id
FROM partners
WHERE id = '某根节点UUID';
-- 预期：is_root = FALSE（不会被触发器改回TRUE）
```

### 验证问题2：子节点不重复显示

```typescript
// 前端测试
// 1. 找一个有子节点的根节点（如中粮集团）
// 2. 展开查看子节点（如中粮）
// 3. 检查"未分配列表"
// 预期：中粮不会出现在未分配列表中
```

### 验证问题3：脱离上级

```typescript
// 前端测试
// 1. 找一个没有下级的子节点
// 2. 点击"脱离上级"按钮
// 3. 确认操作
// 预期：
// - 该节点从树中消失
// - 该节点出现在未分配列表中
// - parent_partner_id = NULL, is_root = FALSE
```

---

## 🎯 功能对比

### 修复前 ❌

| 功能 | 状态 |
|------|------|
| 取消根节点 | ❌ 不生效（被触发器覆盖） |
| 子节点不重复显示 | ❌ 重复显示在树中和列表 |
| 脱离上级 | ❌ 无此功能 |

### 修复后 ✅

| 功能 | 状态 |
|------|------|
| 取消根节点 | ✅ 正常工作 |
| 子节点不重复显示 | ✅ 只在树中显示 |
| 脱离上级 | ✅ 新增功能 |

---

## 📊 操作场景示例

### 场景 1：调整组织架构

**需求**：将"中粮"从"中粮集团"下移除

**操作方式**：

**方式1（推荐）**：点击"脱离上级"
```
中粮集团（根）
  └── 中粮 [脱离上级] ← 点击
        ↓
中粮集团（根）
（中粮移到未分配列表）
```

**方式2**：拖拽到绿色区域
```
中粮集团（根）
  └── 中粮 ← 拖拽
        ↓
┌─────────────────────┐
│ 🏠 拖到这里设为根节点 │ ← 这里
└─────────────────────┘
        ↓
中粮集团（根）
中粮（新根节点）
```

### 场景 2：取消独立根节点

**需求**：取消"武汉方"的根节点设置

**操作**：
```
武汉方（根，无下级）[取消根节点] ← 点击
        ↓
武汉方（移到未分配列表）
```

### 场景 3：重组层级关系

**需求**：将"中粮"从"中粮集团"移到"武汉方"下

**操作**：
```
中粮集团（根）
  └── 中粮 ← 拖拽
武汉方（根）← 拖到这里
        ↓
中粮集团（根）
武汉方（根）
  └── 中粮
```

---

## ⚠️ 使用限制

### 1. 取消根节点

- ✅ 可以操作：没有下级的根节点
- ❌ 不能操作：有下级的根节点

**原因**：避免破坏完整的层级结构

### 2. 脱离上级

- ✅ 可以操作：没有下级的子节点
- ❌ 不能操作：有下级的子节点

**原因**：避免遗留孤儿节点

### 3. 建议操作顺序

如果要拆解一个完整的树：
1. 从最底层（叶子节点）开始
2. 逐个脱离上级或移动
3. 最后处理根节点

---

## 🧪 测试清单

### 功能测试

- [x] 取消根节点（无下级） - 正常工作
- [x] 取消根节点（有下级） - 按钮不显示
- [x] 脱离上级（无下级） - 正常工作
- [x] 脱离上级（有下级） - 按钮不显示
- [x] 子节点不重复显示 - 只在树中显示
- [x] 未分配列表准确 - 只显示真正未分配的

### 数据验证

```sql
-- 测试取消根节点
UPDATE partners 
SET parent_partner_id = NULL, is_root = FALSE 
WHERE id = '某根节点UUID';

-- 验证 is_root 保持 FALSE
SELECT id, name, is_root FROM partners WHERE id = '某根节点UUID';
-- 预期：is_root = FALSE

-- 测试脱离上级
UPDATE partners 
SET parent_partner_id = NULL, is_root = FALSE 
WHERE id = '某子节点UUID';

-- 验证数据正确
SELECT id, name, parent_partner_id, is_root FROM partners WHERE id = '某子节点UUID';
-- 预期：parent_partner_id = NULL, is_root = FALSE
```

---

## 📚 相关文档

- [货主层级管理功能优化说明.md](./货主层级管理功能优化说明.md)
- [货主层级管理功能更新说明.md](./货主层级管理功能更新说明.md)
- [数据库迁移执行顺序说明.md](./数据库迁移执行顺序说明.md)

---

## ✅ 修复总结

本次修复解决了货主层级管理的3个关键问题：

1. ✅ **取消根节点功能正常** - 修改触发器逻辑，允许手动设置 `is_root = false`
2. ✅ **已在树中的子节点不重复显示** - 递归标记树中节点，排除已显示的
3. ✅ **子节点可以脱离上级** - 新增"脱离上级"按钮和处理函数

**状态**: ✅ 所有问题已修复，功能正常！

**需要执行**：
```bash
# 更新数据库触发器
supabase db push
```

---

**修复时间**: 2025-01-22
**影响文件**: 2个（1个迁移文件 + 1个组件文件）
**版本**: v1.3

