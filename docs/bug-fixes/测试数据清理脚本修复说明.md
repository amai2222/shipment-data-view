# 测试数据清理脚本修复说明

## 🐛 问题描述

执行清理测试数据脚本时遇到错误：

```
ERROR: 42703: column lr.partner_id does not exist
```

## 🔍 问题原因

**数据库表结构理解错误**：

1. **原脚本假设**：`logistics_records` 表有 `partner_id` 字段
2. **实际情况**：`logistics_records` 表**没有** `partner_id` 字段

### 正确的数据库关系

根据数据库 schema：

```sql
-- 运单表
CREATE TABLE logistics_records (
    id uuid PRIMARY KEY,
    auto_number text NOT NULL,
    project_id uuid,
    driver_id uuid,
    chain_id uuid,  -- 合作链路ID
    -- 没有 partner_id 字段！
    ...
);

-- 运单合作方成本表（关联表）
CREATE TABLE logistics_partner_costs (
    id uuid PRIMARY KEY,
    logistics_record_id uuid NOT NULL,  -- 运单ID
    partner_id uuid NOT NULL,           -- 合作方ID
    level integer NOT NULL,
    base_amount numeric(12,2),
    payable_amount numeric(12,2),
    ...
);
```

**运单和合作方的关系**：
- 一个运单可以关联**多个合作方**（通过合作链路）
- 关联关系存储在 `logistics_partner_costs` 表中
- **不是直接关联**，而是**多对多关系**

## ✅ 修复方案

### 修改1：统计测试数据

**修复前**：
```sql
SELECT COUNT(*) INTO v_logistics_count
FROM public.logistics_records lr
JOIN public.partners p ON lr.partner_id = p.id  -- ❌ 错误：lr.partner_id 不存在
WHERE p.full_name LIKE '%测试%';
```

**修复后**：
```sql
SELECT COUNT(*) INTO v_logistics_cost_count
FROM public.logistics_partner_costs lpc  -- ✓ 使用正确的关联表
JOIN public.partners p ON lpc.partner_id = p.id
WHERE p.full_name LIKE '%测试%';
```

### 修改2：删除测试数据

**修复前**：
```sql
DELETE FROM public.logistics_records 
WHERE partner_id IN (  -- ❌ 错误：partner_id 不存在
    SELECT id FROM public.partners 
    WHERE full_name LIKE '%测试%'
);
```

**修复后**：
```sql
-- 只删除合作方成本记录，不删除整个运单
DELETE FROM public.logistics_partner_costs 
WHERE partner_id IN (  -- ✓ 正确：在关联表中删除
    SELECT id FROM public.partners 
    WHERE full_name LIKE '%测试%'
);
```

### 修改3：验证清理结果

**修复前**：
```sql
SELECT COUNT(*) as remaining_test_records
FROM public.logistics_records lr
WHERE EXISTS (
    SELECT 1 FROM public.partners p 
    WHERE lr.partner_id = p.id  -- ❌ 错误：lr.partner_id 不存在
    AND p.full_name LIKE '%测试%'
);
```

**修复后**：
```sql
SELECT COUNT(*) as remaining_test_records
FROM public.logistics_partner_costs lpc  -- ✓ 使用正确的关联表
JOIN public.partners p ON lpc.partner_id = p.id
WHERE p.full_name LIKE '%测试%';
```

## 📊 修复后的清理逻辑

### 清理顺序

1. ✅ **删除测试合作方的成本记录**
   - 表：`logistics_partner_costs`
   - 原因：包含外键约束，需要先删除

2. ✅ **删除测试合作方的银行详情**
   - 表：`partner_bank_details`
   - 原因：包含外键约束，需要先删除

3. ✅ **删除测试合作方**
   - 表：`partners`
   - 原因：主表，最后删除

### 为什么不删除运单？

- 运单可能关联**多个合作方**
- 只需删除**测试合作方的成本记录**
- 保留运单本身和其他真实合作方的成本记录

## 🚀 使用方法

修复后的脚本可以安全执行：

1. 登录 Supabase Dashboard
2. 打开 SQL Editor
3. 复制 `执行清理测试数据.sql` 的内容
4. 粘贴并执行

## 📝 预期执行结果

```
============================
发现测试数据统计：
- 测试合作方数量：1
- 测试合作方成本记录数量：5
- 测试银行详情数量：1
============================

开始清理测试数据...
✓ 已删除 5 条测试合作方成本记录
✓ 已删除 1 条测试银行详情
✓ 已删除 1 条测试合作方

============================
测试数据清理完成！
============================

验证清理结果：
table_name             | remaining_test_records
-----------------------+----------------------
partners               | 0
partner_bank_details   | 0
logistics_partner_costs| 0

✓ 测试数据清理完成！
```

## 🎯 关键要点

1. **数据库表结构**：
   - `logistics_records` 表中**没有** `partner_id` 字段
   - 运单和合作方通过 `logistics_partner_costs` 表关联

2. **多对多关系**：
   - 一个运单可以关联多个合作方（合作链路）
   - 不能简单地通过运单表直接关联合作方

3. **清理策略**：
   - 只删除测试合作方的**成本记录**
   - **不删除整个运单**（避免影响其他合作方）

## 🔧 第二次修复：user_id NOT NULL 约束错误

### 问题描述

执行修复后的脚本时遇到新错误：

```
ERROR: 23502: null value in column "user_id" of relation "logistics_partner_costs" violates not-null constraint
```

### 问题原因

删除 `partners` 表记录时，会触发 `ON DELETE CASCADE` 级联删除 `project_partners` 表中的记录，这会触发自动重算触发器：

```sql
CREATE TRIGGER trigger_auto_recalc_on_project_partner_change
  AFTER INSERT OR UPDATE OR DELETE ON public.project_partners
  FOR EACH ROW
  EXECUTE FUNCTION public.auto_recalc_on_project_partner_change();
```

这个触发器调用 `recalculate_costs_for_chain_safe()` 函数重算成本，尝试插入新的 `logistics_partner_costs` 记录，但没有提供 `user_id`。

### 解决方案

在清理测试数据前，**禁用所有触发器**（使用会话级别设置）：

```sql
-- 禁用所有触发器（会话级别）
SET session_replication_role = replica;

-- 清理测试数据
-- ...

-- 重新启用所有触发器
SET session_replication_role = DEFAULT;
```

**为什么使用 `session_replication_role = replica`？**
- ✅ 禁用所有用户定义的触发器
- ✅ 只在当前会话生效，不影响其他连接
- ✅ 比单独禁用触发器更彻底、更可靠
- ✅ 执行完成后自动恢复

### 修复后的清理顺序

1. ✅ **禁用所有触发器** (`SET session_replication_role = replica`)
2. ✅ **删除测试合作方的项目配置** (`project_partners`)
3. ✅ **删除测试合作方的成本记录** (`logistics_partner_costs`)
4. ✅ **删除测试合作方的银行详情** (`partner_bank_details`)
5. ✅ **删除测试合作方** (`partners`)
6. ✅ **重新启用所有触发器** (`SET session_replication_role = DEFAULT`)

## 📅 修复记录

### 第一次修复
- **问题**：`lr.partner_id` 字段不存在
- **时间**：2025-10-25
- **解决**：改用 `logistics_partner_costs` 表关联

### 第二次修复
- **问题**：`user_id` NOT NULL 约束错误（触发器干扰）
- **时间**：2025-10-25
- **解决**：使用 `SET session_replication_role = replica` 禁用所有触发器

---

**修复完成**：脚本已完全修复，可以安全执行！✅

