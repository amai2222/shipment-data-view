# 批量导入函数更新说明

## 更新概述

根据您提供的原始数据库函数代码，我已经更新了 `batch_import_logistics_records` 函数，使其更加完整和实用。

## 主要改进

### 1. 函数签名简化
```sql
-- 更新前
CREATE OR REPLACE FUNCTION public.batch_import_logistics_records(
  p_records JSONB,
  p_template_id UUID DEFAULT NULL,
  p_update_existing BOOLEAN DEFAULT false
)

-- 更新后
CREATE OR REPLACE FUNCTION public.batch_import_logistics_records(
  p_records JSONB
)
```

### 2. 返回类型优化
```sql
-- 更新前
RETURNS TABLE (
  success_count INTEGER,
  error_count INTEGER,
  errors JSONB
)

-- 更新后
RETURNS JSONB
```

### 3. 核心功能增强

#### **自动数据关联**
- ✅ **项目ID自动获取**：根据项目名称自动查找项目ID
- ✅ **合作链路ID自动获取**：根据合作链路名称和项目ID自动查找
- ✅ **司机自动创建**：如果司机不存在，自动创建新司机记录

#### **智能数据处理**
- ✅ **自动编号生成**：使用 `generate_auto_number()` 函数生成运单号
- ✅ **费用自动计算**：插入后自动调用 `recalculate_and_update_costs_for_records()`
- ✅ **数据清理**：使用 `TRIM()` 清理字符串数据

#### **平台字段支持**
- ✅ **external_tracking_numbers**：支持JSONB格式的平台运单号
- ✅ **other_platform_names**：支持TEXT[]格式的平台名称数组
- ✅ **空值处理**：确保平台字段有默认值

#### **错误处理**
- ✅ **详细错误日志**：记录每条失败记录的具体错误信息
- ✅ **事务安全**：单条记录失败不影响其他记录
- ✅ **返回统计**：返回成功数量、错误数量和错误详情

## 函数特性详解

### 1. 数据验证和处理
```sql
-- 项目ID获取
SELECT id INTO project_id_val 
FROM public.projects 
WHERE name = TRIM(record_data->>'project_name') 
LIMIT 1;

-- 合作链路ID获取（可选）
IF record_data->>'chain_name' IS NOT NULL AND TRIM(record_data->>'chain_name') != '' THEN
    SELECT id INTO chain_id_val 
    FROM public.partner_chains 
    WHERE chain_name = TRIM(record_data->>'chain_name') 
    AND project_id = project_id_val
    LIMIT 1;
END IF;
```

### 2. 司机管理
```sql
-- 查找现有司机
SELECT id INTO driver_id_val 
FROM public.drivers 
WHERE name = TRIM(record_data->>'driver_name') 
AND license_plate = TRIM(record_data->>'license_plate')
LIMIT 1;

-- 创建新司机（如果不存在）
IF driver_id_val IS NULL THEN
    INSERT INTO public.drivers (name, license_plate, phone, user_id)
    VALUES (
        TRIM(record_data->>'driver_name'),
        TRIM(record_data->>'license_plate'),
        TRIM(record_data->>'driver_phone'),
        auth.uid()
    )
    RETURNING id INTO driver_id_val;
END IF;
```

### 3. 运单记录插入
```sql
INSERT INTO public.logistics_records (
    auto_number, project_id, project_name, loading_date, loading_location, 
    unloading_location, driver_id, driver_name, license_plate, driver_phone,
    loading_weight, unloading_date, unloading_weight, transport_type,
    current_cost, extra_cost, payable_cost, remarks, created_by_user_id,
    chain_id, external_tracking_numbers, other_platform_names
) VALUES (
    auto_number_val, project_id_val, TRIM(record_data->>'project_name'),
    (record_data->>'loading_date')::timestamptz, TRIM(record_data->>'loading_location'),
    TRIM(record_data->>'unloading_location'), driver_id_val, TRIM(record_data->>'driver_name'),
    TRIM(record_data->>'license_plate'), TRIM(record_data->>'driver_phone'),
    (record_data->>'loading_weight')::numeric, 
    -- 卸货日期处理
    CASE WHEN record_data->>'unloading_date' IS NOT NULL AND TRIM(record_data->>'unloading_date') != '' 
         THEN (record_data->>'unloading_date')::timestamptz ELSE NULL END,
    -- 卸货数量处理
    CASE WHEN record_data->>'unloading_weight' IS NOT NULL AND TRIM(record_data->>'unloading_weight') != '' 
         THEN (record_data->>'unloading_weight')::numeric ELSE NULL END,
    -- 运输类型默认值
    COALESCE(TRIM(record_data->>'transport_type'), '实际运输'),
    -- 费用处理
    CASE WHEN record_data->>'current_cost' IS NOT NULL AND TRIM(record_data->>'current_cost') != '' 
         THEN (record_data->>'current_cost')::numeric ELSE 0 END,
    CASE WHEN record_data->>'extra_cost' IS NOT NULL AND TRIM(record_data->>'extra_cost') != '' 
         THEN (record_data->>'extra_cost')::numeric ELSE 0 END,
    0, -- payable_cost 将在后续计算
    TRIM(record_data->>'remarks'),
    auth.uid(),
    chain_id_val,
    -- 平台字段处理
    CASE WHEN record_data->'external_tracking_numbers' IS NOT NULL 
         THEN record_data->'external_tracking_numbers' ELSE '[]'::jsonb END,
    CASE WHEN record_data->'other_platform_names' IS NOT NULL 
         THEN (record_data->'other_platform_names')::text[] ELSE '{}'::text[] END
)
RETURNING id INTO inserted_record_id;
```

### 4. 费用重新计算
```sql
-- 重新计算费用
PERFORM public.recalculate_and_update_costs_for_records(ARRAY[inserted_record_id]);
```

### 5. 错误处理和返回
```sql
EXCEPTION WHEN OTHERS THEN
    error_count := error_count + 1;
    error_logs := error_logs || jsonb_build_object(
        'record', record_data,
        'error', SQLERRM
    );
END;

-- 返回结果
RETURN jsonb_build_object(
    'success_count', success_count,
    'error_count', error_count,
    'error_logs', error_logs
);
```

## 使用示例

### 1. 基本导入
```sql
SELECT public.batch_import_logistics_records(
  '[
    {
      "project_name": "测试项目",
      "driver_name": "张三",
      "license_plate": "京A12345",
      "driver_phone": "13800138000",
      "loading_location": "北京仓库",
      "unloading_location": "上海仓库",
      "loading_date": "2025-01-20 10:00:00",
      "loading_weight": 1000
    }
  ]'::jsonb
);
```

### 2. 完整数据导入
```sql
SELECT public.batch_import_logistics_records(
  '[
    {
      "project_name": "测试项目",
      "chain_name": "测试合作链路",
      "driver_name": "李四",
      "license_plate": "沪B67890",
      "driver_phone": "13900139000",
      "loading_location": "上海仓库",
      "unloading_location": "广州仓库",
      "loading_date": "2025-01-20 10:00:00",
      "unloading_date": "2025-01-21 15:00:00",
      "loading_weight": 1000,
      "unloading_weight": 950,
      "transport_type": "实际运输",
      "current_cost": 500,
      "extra_cost": 50,
      "remarks": "测试备注",
      "external_tracking_numbers": [
        {"platform": "顺丰", "tracking_number": "SF123456789", "status": "pending", "created_at": "2025-01-20T10:00:00Z"}
      ],
      "other_platform_names": ["顺丰"]
    }
  ]'::jsonb
);
```

## 返回结果格式

```json
{
  "success_count": 1,
  "error_count": 0,
  "error_logs": []
}
```

## 依赖函数

该函数依赖以下数据库函数：
- `public.generate_auto_number(loading_date)` - 生成自动编号
- `public.recalculate_and_update_costs_for_records(record_ids)` - 重新计算费用

## 注意事项

1. **认证要求**：函数使用 `auth.uid()` 获取当前用户ID
2. **数据完整性**：确保项目、司机等关联数据存在
3. **错误处理**：单条记录失败不会影响其他记录
4. **费用计算**：插入后会自动重新计算费用
5. **平台字段**：支持完整的平台运单信息存储

## 更新日志

- **2025-01-20**: 根据原始数据库函数更新批量导入逻辑
- **2025-01-20**: 简化函数签名，优化返回类型
- **2025-01-20**: 增强数据关联和错误处理
- **2025-01-20**: 完善平台字段支持
- **2025-01-20**: 添加费用自动计算功能

## 结论

更新后的 `batch_import_logistics_records` 函数更加完整和实用，能够：
- 自动处理数据关联
- 智能创建缺失记录
- 完整支持平台字段
- 提供详细的错误信息
- 确保数据一致性

这个函数现在可以满足复杂的批量导入需求，同时保持数据的完整性和一致性。
