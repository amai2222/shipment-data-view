# 项目保存逻辑问题分析

## 🎯 用户反馈的真实问题

**用户操作**：在现有合作链路中添加一个合作方  
**期望行为**：只更新被修改的链路中的合作方配置  
**实际行为**：所有链路都被重新保存，触发了自动重算等副作用  

## 🐛 问题本质

### 当前实现方式（错误）

```
用户编辑项目 → 前端发送所有链路数据 → 后端删除所有旧配置 + 插入新配置
```

**问题**：
1. ❌ 用户只改了链路2的合作方，但链路1、链路3也被删除重建了
2. ❌ 触发了 `project_partners` 表的 DELETE + INSERT 操作
3. ❌ DELETE 触发了自动重算触发器：`trigger_auto_recalc_partner_costs`
4. ❌ 所有链路的运单都被重新计算（即使没有修改）
5. ❌ 更新了所有记录的 `updated_at` 时间戳
6. ❌ 可能导致并发冲突和性能问题

### 正确实现方式

```
用户编辑项目 → 前端识别实际修改的内容 → 后端只更新变更的数据
```

**应该实现**：
1. ✅ 只更新被修改的链路
2. ✅ 只触发必要的触发器
3. ✅ 保持未修改数据的原始状态
4. ✅ 避免不必要的重算

## 📊 当前代码流程分析

### 前端代码（src/pages/Projects.tsx）

```typescript
// 编辑时：加载所有链路数据
const chainsWithPartners = (project.partnerChains || []).map(chain => ({
  id: `chain-existing-${chain.id}`, 
  dbId: chain.id,
  // ... 所有字段
  partners: (chain.partners || []).map((pp) => ({
    id: `partner-existing-${pp.id}`, 
    dbId: pp.id,
    // ... 所有字段
  }))
}));

// 保存时：把所有链路数据都发送
const chainsPayload = selectedChains.map((chain, index) => ({
  id: chain.dbId,
  chain_name: chain.chainName || `链路${index + 1}`,
  // ... 所有字段
  partners: chain.partners.map(p => ({
    id: p.dbId,
    partner_id: p.partnerId,
    // ... 所有字段
  }))
}));

// RPC 调用
await supabase.rpc('save_project_with_chains_fixed', {
  project_id_in: projectId,
  project_data: projectPayloadForDb,
  chains_data: chainsPayload  // ❌ 包含所有链路，即使没修改
});
```

### 后端逻辑（推测）

```sql
-- save_project_with_chains_fixed 函数可能的实现
CREATE OR REPLACE FUNCTION save_project_with_chains_fixed(...)
AS $$
BEGIN
  -- 1. 更新项目基本信息
  UPDATE projects SET ... WHERE id = project_id_in;
  
  -- 2. 删除所有旧的链路配置 ❌ 问题在这里！
  DELETE FROM project_partners WHERE project_id = project_id_in;
  DELETE FROM partner_chains WHERE project_id = project_id_in;
  
  -- 3. 插入新的链路配置 ❌ 即使没有修改也重新插入
  INSERT INTO partner_chains ...
  INSERT INTO project_partners ...
END;
$$;
```

**触发器被触发**：
```sql
-- 这个触发器会在 DELETE 和 INSERT 时都触发
CREATE TRIGGER trigger_auto_recalc_partner_costs
  AFTER INSERT OR UPDATE OR DELETE ON public.project_partners
  FOR EACH ROW
  EXECUTE FUNCTION public.auto_recalc_on_project_partner_change();
```

## ✅ 解决方案

### 方案1：前端变更追踪（推荐）⭐

**核心思想**：前端追踪用户的实际修改，只发送变更的数据。

```typescript
// 1. 记录原始状态
const [originalChains, setOriginalChains] = useState<Chain[]>([]);

// 2. 编辑时保存原始状态
const handleEdit = (project) => {
  const chains = project.partnerChains.map(...);
  setSelectedChains(chains);
  setOriginalChains(JSON.parse(JSON.stringify(chains))); // 深拷贝
};

// 3. 保存时比较差异
const handleSubmit = async (e) => {
  // 识别变更
  const changes = detectChanges(originalChains, selectedChains);
  
  // 只发送变更的数据
  await supabase.rpc('update_project_chains_incremental', {
    project_id: projectId,
    added_chains: changes.added,
    updated_chains: changes.updated,
    deleted_chain_ids: changes.deleted,
    added_partners: changes.addedPartners,
    updated_partners: changes.updatedPartners,
    deleted_partner_ids: changes.deletedPartners
  });
};

// 4. 差异检测函数
function detectChanges(original, current) {
  return {
    added: current.filter(c => !c.dbId),
    updated: current.filter(c => c.dbId && hasChanges(c, original)),
    deleted: original.filter(o => !current.find(c => c.dbId === o.dbId)),
    addedPartners: ...,
    updatedPartners: ...,
    deletedPartners: ...
  };
}
```

### 方案2：后端智能合并（简单）⭐⭐

**核心思想**：后端比较新旧数据，只更新真正变化的部分。

```sql
CREATE OR REPLACE FUNCTION save_project_with_chains_smart(
  p_project_id UUID,
  p_project_data JSONB,
  p_chains_data JSONB[]
)
RETURNS VOID AS $$
DECLARE
  v_chain JSONB;
  v_partner JSONB;
  v_existing_chain_id UUID;
BEGIN
  -- 1. 更新项目基本信息
  UPDATE projects SET ... WHERE id = p_project_id;
  
  -- 2. 遍历提交的链路
  FOREACH v_chain IN ARRAY p_chains_data
  LOOP
    v_existing_chain_id := (v_chain->>'id')::UUID;
    
    IF v_existing_chain_id IS NULL THEN
      -- 新增链路
      INSERT INTO partner_chains ...
    ELSE
      -- 只在数据确实变化时才更新
      UPDATE partner_chains 
      SET 
        chain_name = v_chain->>'chain_name',
        description = v_chain->>'description',
        is_default = (v_chain->>'is_default')::BOOLEAN
      WHERE id = v_existing_chain_id
        AND (
          chain_name IS DISTINCT FROM (v_chain->>'chain_name') OR
          description IS DISTINCT FROM (v_chain->>'description') OR
          is_default IS DISTINCT FROM (v_chain->>'is_default')::BOOLEAN
        );
      -- ✅ 如果数据没变，UPDATE 不会执行，不触发触发器
      
      -- 处理合作方：只更新变化的
      FOREACH v_partner IN ARRAY (v_chain->'partners')::JSONB[]
      LOOP
        -- 类似逻辑：只在真正变化时才更新
      END LOOP;
    END IF;
  END LOOP;
  
  -- 3. 删除被移除的链路（如果有）
  DELETE FROM partner_chains 
  WHERE project_id = p_project_id
    AND id NOT IN (
      SELECT (v->>'id')::UUID 
      FROM unnest(p_chains_data) v 
      WHERE v->>'id' IS NOT NULL
    );
END;
$$ LANGUAGE plpgsql;
```

### 方案3：禁用触发器（临时方案）

```sql
-- 编辑现有项目时，只在真正需要重算的情况下触发
CREATE OR REPLACE FUNCTION auto_recalc_on_project_partner_change()
...
BEGIN
  -- 检查是否真的需要重算
  IF TG_OP = 'UPDATE' THEN
    -- 只在关键字段真正变化时才重算
    IF OLD.partner_id IS NOT DISTINCT FROM NEW.partner_id AND
       OLD.level IS NOT DISTINCT FROM NEW.level AND
       OLD.tax_rate IS NOT DISTINCT FROM NEW.tax_rate AND
       OLD.calculation_method IS NOT DISTINCT FROM NEW.calculation_method AND
       OLD.profit_rate IS NOT DISTINCT FROM NEW.profit_rate THEN
      -- 数据没变，直接返回，不触发重算
      RETURN NEW;
    END IF;
  END IF;
  
  -- 执行重算...
END;
$$;
```

## 🎯 推荐实施方案

### 短期方案（立即实施）

**修改触发器逻辑**：让触发器更智能，只在真正需要时才重算。

```sql
-- 修改自动重算触发器
CREATE OR REPLACE FUNCTION public.auto_recalc_on_project_partner_change()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
DECLARE
    v_should_recalc BOOLEAN := FALSE;
BEGIN
    -- 判断是否需要重新计算
    IF TG_OP = 'DELETE' THEN
        v_should_recalc := TRUE;
    ELSIF TG_OP = 'INSERT' THEN
        v_should_recalc := TRUE;
    ELSIF TG_OP = 'UPDATE' THEN
        -- ✅ 只在关键字段真正变化时才重算
        IF OLD.partner_id IS DISTINCT FROM NEW.partner_id OR
           OLD.level IS DISTINCT FROM NEW.level OR
           OLD.tax_rate IS DISTINCT FROM NEW.tax_rate OR
           OLD.calculation_method IS DISTINCT FROM NEW.calculation_method OR
           OLD.profit_rate IS DISTINCT FROM NEW.profit_rate THEN
            v_should_recalc := TRUE;
        ELSE
            -- ✅ 数据没变，直接返回，不触发重算
            RETURN NEW;
        END IF;
    END IF;
    
    -- 执行重算...
    IF v_should_recalc THEN
        -- ...
    END IF;
    
    RETURN NEW;
END;
$$;
```

### 中期方案（1-2周内）

**修改后端保存逻辑**：实现智能合并，只更新变化的数据。

这需要重写 `save_project_with_chains_fixed` 函数。

### 长期方案（未来优化）

**前端实现变更追踪**：使用状态管理库（如 Zustand）追踪用户的实际修改。

## ⚠️ 当前问题的影响

1. **性能问题**：
   - 每次编辑都会触发所有链路的重算
   - 大项目可能有几百条运单需要重算
   - 用户等待时间变长

2. **数据一致性**：
   - `updated_at` 时间戳不准确
   - 无法区分真正的修改和虚假的"保存"

3. **并发冲突**：
   - 多个用户同时编辑同一项目时可能冲突
   - DELETE + INSERT 不是原子操作

4. **触发器副作用**：
   - 自动重算可能覆盖已经手动调整的数据
   - 已付款运单被跳过，但仍然消耗计算资源

## 📅 实施计划

### 立即实施（今天）

1. ✅ 修改触发器：添加数据变化检查
2. ✅ 避免不必要的重算

### 本周内

1. 分析 `save_project_with_chains_fixed` 函数的实际实现
2. 设计智能合并逻辑
3. 编写单元测试

### 下周

1. 实现新的保存逻辑
2. 测试验证
3. 上线部署

---

**总结**：当前的"全量保存"方式简单但低效，应该改为"增量更新"方式，只修改用户实际变更的数据。🎯

