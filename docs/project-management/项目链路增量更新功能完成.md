# 项目链路增量更新功能完成 ✅

## 🎯 功能说明

**需求**：在项目管理中，只修改某个链路的合作方时，只重算和保存该链路，不影响其他链路。

**实现**：增量更新 - 检测实际变更，只更新变更的部分。

## ✅ 已完成的修改

### 1. 后端函数（SQL）

**文件**：`supabase/migrations/20251025_create_incremental_update_function.sql`

**功能**：
- 创建 `update_project_chains_incremental` 函数
- 只更新变更的链路
- 只删除被移除的链路
- 只触发必要的重算

### 2. 前端逻辑（TypeScript）

**文件**：`src/pages/Projects.tsx`

**新增状态**：
```typescript
const [originalChains, setOriginalChains] = useState<typeof selectedChains>([]);
```

**新增功能**：
1. ✅ 编辑时保存原始数据
2. ✅ 检测变更的链路
3. ✅ 区分编辑模式和新建模式
4. ✅ 只发送变更的数据

---

## 🔧 核心实现

### 前端变更检测

```typescript
// 1. 编辑时保存原始数据
const handleEdit = (project: ProjectWithDetails) => {
  const chainsWithPartners = ...;
  setSelectedChains(chainsWithPartners);
  setOriginalChains(JSON.parse(JSON.stringify(chainsWithPartners))); // 深拷贝
};

// 2. 检测哪些链路被修改了
const detectChangedChains = () => {
  return selectedChains.filter((chain) => {
    const original = originalChains.find(o => o.dbId === chain.dbId);
    if (!original) return true; // 新增的链路
    
    // 比较合作方配置（只比对关键字段）
    const currentPartners = JSON.stringify(
      chain.partners.map(p => ({
        partnerId: p.partnerId,
        level: p.level,
        taxRate: p.taxRate,
        calculationMethod: p.calculationMethod,
        profitRate: p.profitRate
      })).sort((a, b) => a.level - b.level)
    );
    
    const originalPartners = JSON.stringify(...);
    
    return currentPartners !== originalPartners;
  });
};

// 3. 检测被删除的链路
const deletedChainIds = originalChains
  .filter(o => o.dbId && !selectedChains.find(c => c.dbId === o.dbId))
  .map(o => o.dbId);
```

### 后端增量更新

```sql
CREATE FUNCTION update_project_chains_incremental(...)
AS $$
BEGIN
  -- 1. 更新项目基本信息
  UPDATE projects SET ... WHERE id = p_project_id;
  
  -- 2. 删除被移除的链路
  DELETE FROM partner_chains WHERE id = ANY(p_deleted_chain_ids);
  
  -- 3. 只处理变更的链路
  FOREACH v_chain IN ARRAY p_changed_chains
  LOOP
    IF v_chain_id IS NULL THEN
      -- 新增链路
      INSERT INTO partner_chains ...;
    ELSE
      -- 更新现有链路（只在数据变化时更新）
      UPDATE partner_chains SET ... WHERE id = v_chain_id AND (数据变化);
    END IF;
    
    -- 删除该链路的旧合作方配置
    DELETE FROM project_partners WHERE chain_id = v_chain_id;
    
    -- 插入新的合作方配置
    INSERT INTO project_partners ...;
    
    -- ✅ 只会触发该链路的重算
  END LOOP;
END;
$$;
```

---

## 📊 效果对比

### 场景：在链路2添加一个合作方

**修改前（全量保存）** ❌：
```
用户操作：
  项目有3个链路，在链路2添加合作商F

系统行为：
  1. DELETE 所有3个链路的 project_partners 配置
     ↓ 触发链路1、2、3的 DELETE 触发器 ❌
  2. INSERT 所有3个链路的 project_partners 配置
     ↓ 触发链路1、2、3的 INSERT 触发器 ❌
  3. 重算链路1、2、3的所有运单 ❌

结果：
  - 链路1被重算 ❌ 不应该
  - 链路2被重算 ✅ 正确
  - 链路3被重算 ❌ 不应该
  - 所有链路的 updated_at 都改变了 ❌
```

**修改后（增量更新）** ✅：
```
用户操作：
  项目有3个链路，在链路2添加合作商F

系统行为：
  1. 检测变更：只有链路2被修改 ✅
  2. DELETE 链路2的 project_partners 配置
     ↓ 只触发链路2的 DELETE 触发器 ✅
  3. INSERT 链路2的新 project_partners 配置
     ↓ 只触发链路2的 INSERT 触发器 ✅
  4. 只重算链路2的运单 ✅
  5. 链路1、3完全不受影响 ✅

结果：
  - 链路1不动 ✅ 正确
  - 链路2被重算 ✅ 正确
  - 链路3不动 ✅ 正确
  - 只有链路2的 updated_at 改变 ✅
```

### 场景：只修改项目基本信息

**修改前** ❌：
```
用户操作：
  只修改项目名称

系统行为：
  1. DELETE 所有链路的配置 ❌
  2. INSERT 所有链路的配置 ❌
  3. 重算所有链路的运单 ❌

结果：不必要的重算
```

**修改后** ✅：
```
用户操作：
  只修改项目名称

系统行为：
  1. 检测变更：没有链路被修改 ✅
  2. 只 UPDATE projects 表 ✅
  3. 不触及任何链路 ✅
  4. 不触发任何重算 ✅

结果：高效、精准
```

---

## 🚀 部署步骤

### 第1步：执行数据库脚本

在 Supabase Dashboard 执行：
```sql
supabase/migrations/20251025_create_incremental_update_function.sql
```

**验证**：执行后应看到成功消息
```
✓ 项目链路增量更新函数创建完成
```

### 第2步：部署前端代码

```bash
git add src/pages/Projects.tsx
git commit -m "实现项目链路增量更新功能

- 添加原始数据保存
- 实现变更检测逻辑
- 区分编辑和新建模式
- 只更新变更的链路
- 避免不必要的重算"
git push
```

### 第3步：验证功能

测试用例见下方"测试清单"。

---

## 🧪 测试清单

### 测试1：只修改一个链路

**步骤**：
1. 编辑一个有3个链路的项目
2. 在链路2添加一个合作方
3. 保存

**预期结果**：
- ✅ Toast 提示：`已更新 1 条链路，删除 0 条链路`
- ✅ 只有链路2的运单被重算
- ✅ 链路1和3完全不动

### 测试2：只修改项目基本信息

**步骤**：
1. 编辑项目
2. 只修改项目名称
3. 不修改任何链路
4. 保存

**预期结果**：
- ✅ Toast 提示：`仅更新了项目基本信息`
- ✅ 没有链路被触及
- ✅ 没有触发任何重算

### 测试3：删除一个链路

**步骤**：
1. 编辑项目
2. 删除链路3
3. 保存

**预期结果**：
- ✅ Toast 提示：`已更新 0 条链路，删除 1 条链路`
- ✅ 链路3被删除
- ✅ 链路1和2不受影响

### 测试4：新建项目

**步骤**：
1. 点击"新增项目"
2. 填写信息并配置链路
3. 保存

**预期结果**：
- ✅ 使用原有的全量保存逻辑
- ✅ 所有链路正常创建
- ✅ Toast 提示：`项目创建成功`

### 测试5：修改多个链路

**步骤**：
1. 编辑项目
2. 在链路1添加合作方
3. 在链路2删除合作方
4. 保存

**预期结果**：
- ✅ Toast 提示：`已更新 2 条链路，删除 0 条链路`
- ✅ 链路1和2被更新和重算
- ✅ 链路3不受影响

---

## 🎓 技术亮点

### 1. 智能变更检测

```typescript
// 只比对关键字段，忽略 UI 相关字段
const currentPartners = JSON.stringify(
  chain.partners.map(p => ({
    partnerId: p.partnerId,      // 业务字段
    level: p.level,              // 业务字段
    taxRate: p.taxRate,          // 业务字段
    calculationMethod: p.calculationMethod,  // 业务字段
    profitRate: p.profitRate     // 业务字段
    // 忽略：id, dbId, partnerName（UI字段）
  })).sort((a, b) => a.level - b.level)  // 排序保证一致性
);
```

### 2. 双模式支持

```typescript
if (projectId) {
  // 编辑模式：增量更新
  const changedChains = detectChangedChains();
  await supabase.rpc('update_project_chains_incremental', ...);
} else {
  // 新建模式：全量保存
  await supabase.rpc('save_project_with_chains_fixed', ...);
}
```

### 3. 精准的用户反馈

```typescript
if (changedChains.length > 0 || deletedChainIds.length > 0) {
  toast({ 
    title: "项目更新成功", 
    description: `已更新 ${changedChains.length} 条链路，删除 ${deletedChainIds.length} 条链路` 
  });
} else {
  toast({ title: "项目更新成功", description: "仅更新了项目基本信息" });
}
```

### 4. 后端智能比对

```sql
-- 只在数据真正变化时才更新
UPDATE partner_chains
SET ...
WHERE id = v_chain_id
  AND (
    chain_name IS DISTINCT FROM (v_chain->>'chain_name') OR
    description IS DISTINCT FROM ... OR
    is_default IS DISTINCT FROM ... OR
    billing_type_id IS DISTINCT FROM ...
  );

IF FOUND THEN
  RAISE NOTICE '✓ 更新链路基本信息: %', v_chain->>'chain_name';
ELSE
  RAISE NOTICE '- 链路基本信息未变化: %', v_chain->>'chain_name';
END IF;
```

---

## 📊 性能提升

### 数据库操作对比

**修改前**（3个链路，只修改链路2）：
```
DELETE 操作：3 条链路 × 平均2个合作方 = 6 次
INSERT 操作：3 条链路 × 平均2个合作方 = 6 次
触发重算：3 个链路
总操作：12 次数据库写入
```

**修改后**（3个链路，只修改链路2）：
```
DELETE 操作：1 条链路 × 2个合作方 = 2 次
INSERT 操作：1 条链路 × 2个合作方 = 2 次
触发重算：1 个链路
总操作：4 次数据库写入
```

**性能提升**：**67%** 减少 ✅

### 重算运单对比

**假设**：
- 项目有 100 条运单
- 链路1：40条运单
- 链路2：30条运单
- 链路3：30条运单

**修改前**：
```
重算运单：100 条（所有链路）
耗时：假设 5 秒
```

**修改后**：
```
重算运单：30 条（只有链路2）
耗时：假设 1.5 秒
```

**性能提升**：**70%** 减少 ✅

---

## 🎯 使用示例

### 示例1：在链路2添加合作方

```
用户操作：
  1. 编辑项目"可口可乐1008"
  2. 在链路2添加合作商"张海宽"
  3. 点击保存

系统行为：
  1. 检测变更：链路2被修改
  2. 调用 update_project_chains_incremental
  3. 只更新链路2的配置
  4. 只重算链路2的运单
  5. Toast：已更新 1 条链路，删除 0 条链路

日志输出：
  ✓ 已更新项目基本信息
  ✓ 更新链路: 链路2
  ✓ 插入 3 个新合作方配置
  增量更新完成：
    - 更新链路: 1 条
    - 删除链路: 0 条
    - 更新合作方配置: 3 个
```

### 示例2：只修改项目名称

```
用户操作：
  1. 编辑项目"可口可乐1008"
  2. 将名称改为"可口可乐"
  3. 不修改任何链路
  4. 点击保存

系统行为：
  1. 检测变更：没有链路被修改
  2. 只更新 projects 表
  3. 不触及 partner_chains 和 project_partners
  4. Toast：仅更新了项目基本信息

结果：
  - 没有触发任何重算 ✅
  - 链路配置完全不动 ✅
```

---

## ⚠️ 注意事项

### 1. 兼容性

- ✅ **新建项目**：继续使用 `save_project_with_chains_fixed`（全量保存）
- ✅ **编辑项目**：使用 `update_project_chains_incremental`（增量更新）
- ✅ 完全向后兼容

### 2. 触发器执行

- ✅ 只有变更的链路会触发 DELETE + INSERT
- ✅ 未变更的链路不会触发任何操作
- ✅ 配合 `修复触发器避免不必要重算.sql` 效果更佳

### 3. 数据一致性

- ✅ 使用事务保证原子性
- ✅ 外键约束保证完整性
- ✅ 触发器保证成本正确性

### 4. 错误处理

- ✅ 前端有完整的表单验证
- ✅ 后端有详细的日志输出
- ✅ 错误时 Toast 提示用户

---

## 🔍 调试日志

### 开启详细日志

在 Supabase Dashboard 的 SQL Editor 中执行：
```sql
-- 查看函数执行日志
SELECT * FROM pg_stat_user_functions 
WHERE funcname = 'update_project_chains_incremental';

-- 查看最近的 NOTICE 日志（需要在 psql 中）
-- RAISE NOTICE 的消息会输出到客户端
```

### 日志示例

```
========================================
开始增量更新项目链路
项目ID: abc-123-def
变更链路数: 1
删除链路数: 0
========================================
✓ 已更新项目基本信息
✓ 更新链路: 链路2
  - 删除该链路的 2 个旧合作方配置
  ✓ 插入 3 个新合作方配置
========================================
增量更新完成：
  - 更新链路: 1 条
  - 删除链路: 0 条
  - 更新合作方配置: 3 个
========================================
```

---

## 🎯 总结

### 核心改进

1. ✅ **精准更新**：只更新实际变更的数据
2. ✅ **性能提升**：减少 60-70% 的数据库操作
3. ✅ **避免副作用**：不触发不必要的重算
4. ✅ **用户体验**：清晰的反馈信息

### 技术价值

- ✅ 符合增量更新最佳实践
- ✅ 减少数据库负载
- ✅ 提升系统响应速度
- ✅ 保持数据时间戳准确性

### 业务价值

- ✅ 用户操作更快速
- ✅ 系统更稳定
- ✅ 避免误触发重算导致的数据问题
- ✅ 准确的操作历史记录

---

**功能已完全实现！现在编辑项目时，只会更新你实际修改的链路！** 🎉

