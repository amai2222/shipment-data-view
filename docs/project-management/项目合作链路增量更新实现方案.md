# 项目合作链路增量更新实现方案

## 🎯 需求

**核心需求**：
- 用户只修改了链路2的合作方（增加或删除）
- 系统应该只保存和重算链路2
- 链路1、链路3不应该被触及

## 📊 实现方案

### 方案选择

#### 方案A：前端变更追踪（复杂，完美）
- 优点：最优雅，完全避免不必要的更新
- 缺点：需要大量前端代码重构

#### 方案B：后端智能比对（中等，推荐）⭐
- 优点：前端改动小，后端智能处理
- 缺点：需要后端比对逻辑

#### 方案C：前端标记变更（简单，实用）⭐⭐
- 优点：实现简单，前端可控
- 缺点：需要维护变更标记

### 推荐实施：方案C + 方案B 组合

---

## 🔧 实施步骤

### 第1步：前端标记变更的链路

在 `src/pages/Projects.tsx` 中添加变更追踪：

```typescript
// 1. 记录原始数据
const [originalChains, setOriginalChains] = useState<any[]>([]);

// 2. 编辑时保存原始数据
const handleEdit = (project: ProjectWithDetails) => {
  // ... 现有代码 ...
  
  const chainsWithPartners = (project.partnerChains || []).map(chain => ({
    id: `chain-existing-${chain.id}`, 
    dbId: chain.id, 
    chainName: chain.chainName,
    description: chain.description,
    billingTypeId: Number((chain as any).billing_type_id) || 1,
    isDefault: (chain as any).is_default || false,
    partners: (chain.partners || []).map((pp) => ({
      id: `partner-existing-${pp.id}`, 
      dbId: pp.id, 
      partnerId: pp.partnerId,
      level: pp.level, 
      taxRate: pp.taxRate,
      calculationMethod: pp.calculationMethod || "tax",
      profitRate: pp.profitRate || 0, 
      partnerName: pp.partnerName
    }))
  }));
  
  setSelectedChains(chainsWithPartners);
  setOriginalChains(JSON.parse(JSON.stringify(chainsWithPartners))); // ✅ 深拷贝保存原始数据
  setIsDialogOpen(true);
};

// 3. 检测变更的链路
const detectChangedChains = () => {
  return selectedChains.filter((chain, index) => {
    const original = originalChains.find(o => o.dbId === chain.dbId);
    if (!original) return true; // 新增的链路
    
    // 比较合作方是否变化
    const currentPartners = JSON.stringify(chain.partners.map(p => ({
      partnerId: p.partnerId,
      level: p.level,
      taxRate: p.taxRate,
      calculationMethod: p.calculationMethod,
      profitRate: p.profitRate
    })));
    
    const originalPartners = JSON.stringify(original.partners.map(p => ({
      partnerId: p.partnerId,
      level: p.level,
      taxRate: p.taxRate,
      calculationMethod: p.calculationMethod,
      profitRate: p.profitRate
    })));
    
    return currentPartners !== originalPartners;
  });
};

// 4. 保存时只发送变更的链路
const handleSubmit = async (e: React.FormEvent) => {
  e.preventDefault();
  
  // ... 验证代码 ...
  
  try {
    setIsSubmitting(true);
    const projectId = editingProject ? editingProject.id : null;
    
    // 更新项目基本信息
    const projectPayloadForDb = { ... };
    
    if (projectId) {
      // ✅ 编辑模式：只更新变更的链路
      const changedChains = detectChangedChains();
      const deletedChainIds = originalChains
        .filter(o => !selectedChains.find(c => c.dbId === o.dbId))
        .map(o => o.dbId)
        .filter(id => id);
      
      if (changedChains.length > 0 || deletedChainIds.length > 0) {
        // 只发送变更的链路
        const { error } = await supabase.rpc('update_project_chains_incremental', {
          p_project_id: projectId,
          p_project_data: projectPayloadForDb,
          p_changed_chains: changedChains.map((chain, index) => ({
            id: chain.dbId,
            chain_name: chain.chainName,
            description: chain.description,
            is_default: chain.isDefault,
            billing_type_id: chain.billingTypeId,
            partners: chain.partners.map(p => ({
              id: p.dbId,
              partner_id: p.partnerId,
              level: Number(p.level),
              tax_rate: Number(p.taxRate),
              calculation_method: p.calculationMethod,
              profit_rate: Number(p.profitRate)
            }))
          })),
          p_deleted_chain_ids: deletedChainIds
        });
        
        if (error) throw error;
      } else {
        // 只更新项目基本信息，不动链路
        const { error } = await supabase
          .from('projects')
          .update(projectPayloadForDb)
          .eq('id', projectId);
        
        if (error) throw error;
      }
    } else {
      // ✅ 新建模式：使用原有逻辑
      const chainsPayload = selectedChains.map((chain, index) => ({
        id: chain.dbId,
        chain_name: chain.chainName || `链路${index + 1}`,
        description: chain.description || '',
        is_default: chain.isDefault !== undefined ? chain.isDefault : (index === 0),
        billing_type_id: chain.billingTypeId ?? 1,
        partners: chain.partners.map(p => ({
          id: p.dbId,
          partner_id: p.partnerId,
          level: Number(p.level),
          tax_rate: Number(p.taxRate) || 0,
          calculation_method: p.calculationMethod || 'tax',
          profit_rate: Number(p.profitRate) || 0
        }))
      }));
      
      const { error } = await supabase.rpc('save_project_with_chains_fixed', {
        project_id_in: null,
        project_data: projectPayloadForDb,
        chains_data: chainsPayload
      });
      
      if (error) throw error;
    }
    
    toast({ title: editingProject ? "项目更新成功" : "项目创建成功" });
    await queryClient.invalidateQueries({ queryKey: ['projects-with-details'] });
    setIsDialogOpen(false);
    resetForm();
  } catch (error) {
    console.error('保存项目失败:', error);
    toast({ title: "操作失败", variant: "destructive" });
  } finally {
    setIsSubmitting(false);
  }
};
```

---

## 📝 第2步：创建后端增量更新函数

创建新的 SQL 文件：`supabase/migrations/xxx_create_incremental_update_function.sql`

```sql
-- ============================================================
-- 创建增量更新项目链路的函数
-- ============================================================

CREATE OR REPLACE FUNCTION public.update_project_chains_incremental(
    p_project_id UUID,
    p_project_data JSONB,
    p_changed_chains JSONB[],
    p_deleted_chain_ids UUID[] DEFAULT ARRAY[]::UUID[]
)
RETURNS JSONB
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path TO 'public'
AS $$
DECLARE
    v_chain JSONB;
    v_chain_id UUID;
    v_partner JSONB;
    v_partner_id UUID;
    v_updated_chains INTEGER := 0;
    v_deleted_chains INTEGER := 0;
    v_updated_partners INTEGER := 0;
BEGIN
    -- 1. 更新项目基本信息
    UPDATE public.projects
    SET 
        name = p_project_data->>'name',
        start_date = (p_project_data->>'start_date')::DATE,
        end_date = (p_project_data->>'end_date')::DATE,
        manager = p_project_data->>'manager',
        loading_address = p_project_data->>'loading_address',
        unloading_address = p_project_data->>'unloading_address',
        finance_manager = p_project_data->>'finance_manager',
        planned_total_tons = (p_project_data->>'planned_total_tons')::NUMERIC,
        project_status = p_project_data->>'project_status',
        cargo_type = p_project_data->>'cargo_type',
        effective_quantity_type = p_project_data->>'effective_quantity_type',
        updated_at = NOW()
    WHERE id = p_project_id;
    
    RAISE NOTICE '✓ 已更新项目基本信息';
    
    -- 2. 删除被移除的链路
    IF array_length(p_deleted_chain_ids, 1) > 0 THEN
        DELETE FROM public.partner_chains
        WHERE id = ANY(p_deleted_chain_ids);
        
        GET DIAGNOSTICS v_deleted_chains = ROW_COUNT;
        RAISE NOTICE '✓ 已删除 % 条链路', v_deleted_chains;
    END IF;
    
    -- 3. 处理变更的链路
    FOREACH v_chain IN ARRAY p_changed_chains
    LOOP
        v_chain_id := (v_chain->>'id')::UUID;
        
        IF v_chain_id IS NULL THEN
            -- 新增链路
            INSERT INTO public.partner_chains (
                project_id,
                chain_name,
                description,
                is_default,
                billing_type_id,
                user_id
            ) VALUES (
                p_project_id,
                v_chain->>'chain_name',
                v_chain->>'description',
                (v_chain->>'is_default')::BOOLEAN,
                (v_chain->>'billing_type_id')::BIGINT,
                auth.uid()
            ) RETURNING id INTO v_chain_id;
            
            RAISE NOTICE '✓ 新增链路: %', v_chain->>'chain_name';
        ELSE
            -- 更新现有链路（只在数据变化时更新）
            UPDATE public.partner_chains
            SET 
                chain_name = v_chain->>'chain_name',
                description = v_chain->>'description',
                is_default = (v_chain->>'is_default')::BOOLEAN,
                billing_type_id = (v_chain->>'billing_type_id')::BIGINT,
                updated_at = NOW()
            WHERE id = v_chain_id
              AND (
                chain_name IS DISTINCT FROM (v_chain->>'chain_name') OR
                description IS DISTINCT FROM (v_chain->>'description') OR
                is_default IS DISTINCT FROM (v_chain->>'is_default')::BOOLEAN OR
                billing_type_id IS DISTINCT FROM (v_chain->>'billing_type_id')::BIGINT
              );
            
            IF FOUND THEN
                RAISE NOTICE '✓ 更新链路: %', v_chain->>'chain_name';
            END IF;
        END IF;
        
        v_updated_chains := v_updated_chains + 1;
        
        -- 4. 删除该链路的所有旧合作方配置
        DELETE FROM public.project_partners
        WHERE chain_id = v_chain_id;
        
        -- 5. 插入新的合作方配置
        FOR i IN 0..jsonb_array_length(v_chain->'partners')-1
        LOOP
            v_partner := v_chain->'partners'->i;
            v_partner_id := (v_partner->>'id')::UUID;
            
            INSERT INTO public.project_partners (
                project_id,
                chain_id,
                partner_id,
                level,
                tax_rate,
                calculation_method,
                profit_rate,
                user_id
            ) VALUES (
                p_project_id,
                v_chain_id,
                (v_partner->>'partner_id')::UUID,
                (v_partner->>'level')::INTEGER,
                (v_partner->>'tax_rate')::NUMERIC,
                v_partner->>'calculation_method',
                (v_partner->>'profit_rate')::NUMERIC,
                auth.uid()
            );
            
            v_updated_partners := v_updated_partners + 1;
        END LOOP;
        
        RAISE NOTICE '✓ 更新链路 % 的合作方配置: % 个合作方', 
                     v_chain->>'chain_name', 
                     jsonb_array_length(v_chain->'partners');
    END LOOP;
    
    -- 6. 返回结果
    RETURN jsonb_build_object(
        'success', true,
        'message', format('成功更新 %s 条链路，删除 %s 条链路，更新 %s 个合作方配置', 
                         v_updated_chains, v_deleted_chains, v_updated_partners),
        'updated_chains', v_updated_chains,
        'deleted_chains', v_deleted_chains,
        'updated_partners', v_updated_partners
    );
END;
$$;

COMMENT ON FUNCTION public.update_project_chains_incremental IS '增量更新项目链路配置（只更新变更的链路，不影响其他链路）';
```

---

## 💡 关键设计

### 1. 前端变更检测

```typescript
// 检测哪些链路被修改了
const detectChangedChains = () => {
  return selectedChains.filter((chain) => {
    const original = originalChains.find(o => o.dbId === chain.dbId);
    
    // 新增的链路
    if (!original) return true;
    
    // 比较合作方配置
    const currentPartners = JSON.stringify(
      chain.partners.map(p => ({
        partnerId: p.partnerId,
        level: p.level,
        taxRate: p.taxRate,
        calculationMethod: p.calculationMethod,
        profitRate: p.profitRate
      }))
    );
    
    const originalPartners = JSON.stringify(
      original.partners.map(p => ({
        partnerId: p.partnerId,
        level: p.level,
        taxRate: p.taxRate,
        calculationMethod: p.calculationMethod,
        profitRate: p.profitRate
      }))
    );
    
    return currentPartners !== originalPartners;
  });
};
```

### 2. 后端只处理变更的链路

```sql
-- 遍历提交的链路（只包含变更的）
FOREACH v_chain IN ARRAY p_changed_chains
LOOP
    -- 删除该链路的旧配置
    DELETE FROM project_partners WHERE chain_id = v_chain_id;
    
    -- 插入新的配置
    INSERT INTO project_partners (...) VALUES (...);
    
    -- ✅ 只会触发这个链路的重算，不影响其他链路
END LOOP;
```

### 3. 触发器只重算变更的链路

```sql
-- 触发器在 DELETE/INSERT 时触发
-- 但只会影响 chain_id = v_chain_id 的运单
CREATE TRIGGER trigger_auto_recalc_partner_costs
    AFTER INSERT OR UPDATE OR DELETE ON public.project_partners
    FOR EACH ROW
    EXECUTE FUNCTION auto_recalc_on_project_partner_change();
```

---

## 🎯 预期效果

### 场景1：在链路2添加一个合作方

**用户操作**：
```
项目有3个链路
- 链路1：合作商A → 合作商B
- 链路2：合作商C
- 链路3：合作商D → 合作商E

用户在链路2添加合作商F：
- 链路2：合作商C → 合作商F
```

**系统行为（修改前）**：❌
```
1. DELETE 所有3个链路的配置
2. INSERT 所有3个链路的配置
3. 触发器重算所有3个链路的运单
```

**系统行为（修改后）**：✅
```
1. 只 DELETE 链路2的配置
2. 只 INSERT 链路2的新配置
3. 触发器只重算链路2的运单
4. 链路1和链路3完全不受影响
```

### 场景2：只修改项目基本信息

**用户操作**：
```
只修改项目名称：可口可乐 → 可口可乐1008
不修改任何链路
```

**系统行为（修改后）**：✅
```
1. 只 UPDATE projects 表
2. 不触及 partner_chains 和 project_partners 表
3. 不触发任何重算
```

---

## 📊 实施计划

### Phase 1：创建后端函数（今天）

1. ✅ 创建 `update_project_chains_incremental` 函数
2. ✅ 测试函数功能
3. ✅ 部署到数据库

### Phase 2：修改前端逻辑（明天）

1. ✅ 添加原始数据保存
2. ✅ 实现变更检测
3. ✅ 修改保存逻辑（区分新建和编辑）
4. ✅ 测试功能

### Phase 3：测试验证（后天）

1. ✅ 功能测试
2. ✅ 性能测试
3. ✅ 回归测试
4. ✅ 上线部署

---

## ⚠️ 注意事项

### 1. 兼容性

- ✅ 新建项目仍使用原有逻辑（`save_project_with_chains_fixed`）
- ✅ 编辑项目使用新逻辑（`update_project_chains_incremental`）
- ✅ 向后兼容

### 2. 触发器影响

- ✅ 只有变更的链路会触发 DELETE + INSERT
- ✅ 其他链路不会触发任何操作
- ✅ 配合触发器优化脚本，效果更好

### 3. 数据一致性

- ✅ 使用事务保证原子性
- ✅ 外键约束保证完整性
- ✅ 触发器保证成本计算正确性

---

## 🎓 技术要点

### JSON 序列化比对

```typescript
// 只比对关键字段
const currentPartners = JSON.stringify(
  chain.partners.map(p => ({
    partnerId: p.partnerId,  // 关键
    level: p.level,          // 关键
    taxRate: p.taxRate,      // 关键
    calculationMethod: p.calculationMethod,  // 关键
    profitRate: p.profitRate  // 关键
  }))
);

// 忽略 UI 相关字段（id, dbId, partnerName）
```

### JSONB 数组遍历

```sql
-- 遍历 JSONB 数组
FOR i IN 0..jsonb_array_length(v_chain->'partners')-1
LOOP
    v_partner := v_chain->'partners'->i;
    -- 处理每个合作方
END LOOP;
```

---

**下一步：我立即为你实现这个方案！**

