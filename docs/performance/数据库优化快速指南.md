# 数据库查询优化快速指南

## 🚀 立即使用

### 1. 清理console日志

```bash
# 运行日志清理脚本
cd shipment-data-view
node scripts/clean-console-logs.js
```

**效果**:
- 自动清理所有console.log
- 保留console.error和KEEP标记的日志
- 提升生产环境性能

### 2. 优化已完成的文件

已优化的文件会自动生效，无需额外配置：
- ✅ `src/pages/mobile/MobileProjectOverview.tsx`
- ✅ `src/pages/mobile/MobileProjects.tsx`

---

## 📊 性能对比

### 移动端项目看板

| 场景 | 优化前 | 优化后 | 提升 |
|------|--------|--------|------|
| 20个项目加载 | ~2秒 | ~0.1秒 | **20倍** |
| 数据库查询 | 41次 | 2次 | **95%减少** |
| 网络请求 | 41个 | 2个 | **95%减少** |

---

## 🎯 N+1查询识别

### ❌ 反面案例（N+1问题）

```typescript
// 第一次查询：获取所有项目
const projects = await supabase.from('projects').select('*');

// N次查询：为每个项目查询统计数据
for (const project of projects) {
  const stats = await supabase
    .from('logistics_records')
    .select('*')
    .eq('project_id', project.id);
}
// 总查询数：1 + N = 21次（N=20）
```

### ✅ 正确做法（批量查询）

```typescript
// 第一次查询：获取所有项目
const projects = await supabase.from('projects').select('*');
const projectIds = projects.map(p => p.id);

// 第二次查询：批量获取所有统计数据
const allStats = await supabase
  .from('logistics_records')
  .select('*')
  .in('project_id', projectIds);

// 在内存中聚合
const statsMap = new Map();
allStats.forEach(stat => {
  // 聚合逻辑
});
// 总查询数：2次！
```

---

## 🔧 常见场景优化

### 场景1: 关联数据查询

```typescript
// ❌ 不好
async function getProjectsWithRecords() {
  const projects = await db.query('SELECT * FROM projects');
  
  for (const project of projects) {
    project.records = await db.query(
      'SELECT * FROM logistics_records WHERE project_id = ?',
      [project.id]
    );
  }
  return projects;
}

// ✅ 好
async function getProjectsWithRecords() {
  const projects = await db.query('SELECT * FROM projects');
  const projectIds = projects.map(p => p.id);
  
  const allRecords = await db.query(
    'SELECT * FROM logistics_records WHERE project_id IN (?)',
    [projectIds]
  );
  
  // 在内存中组合
  const recordsMap = groupBy(allRecords, 'project_id');
  projects.forEach(p => {
    p.records = recordsMap[p.id] || [];
  });
  
  return projects;
}
```

### 场景2: 统计数据计算

```typescript
// ❌ 不好
async function getProjectStats() {
  const projects = await db.query('SELECT * FROM projects');
  
  for (const project of projects) {
    const stats = await db.query(`
      SELECT COUNT(*) as count, SUM(weight) as total
      FROM logistics_records
      WHERE project_id = ?
    `, [project.id]);
    project.stats = stats[0];
  }
}

// ✅ 好
async function getProjectStats() {
  const [projects, allStats] = await Promise.all([
    db.query('SELECT * FROM projects'),
    db.query(`
      SELECT 
        project_id,
        COUNT(*) as count,
        SUM(weight) as total
      FROM logistics_records
      GROUP BY project_id
    `)
  ]);
  
  const statsMap = new Map(
    allStats.map(s => [s.project_id, s])
  );
  
  projects.forEach(p => {
    p.stats = statsMap.get(p.id) || { count: 0, total: 0 };
  });
}
```

### 场景3: 并行查询

```typescript
// ❌ 不好 - 串行查询
async function getDashboardData() {
  const users = await db.query('SELECT * FROM users');
  const projects = await db.query('SELECT * FROM projects');
  const records = await db.query('SELECT * FROM records');
  return { users, projects, records };
}
// 总耗时：50ms + 50ms + 50ms = 150ms

// ✅ 好 - 并行查询
async function getDashboardData() {
  const [users, projects, records] = await Promise.all([
    db.query('SELECT * FROM users'),
    db.query('SELECT * FROM projects'),
    db.query('SELECT * FROM records')
  ]);
  return { users, projects, records };
}
// 总耗时：max(50ms, 50ms, 50ms) = 50ms
```

---

## 📝 检查清单

在编写数据库查询代码时，问自己：

- [ ] 我是否在循环中查询数据库？
- [ ] 我能否用一次查询代替多次查询？
- [ ] 我能否使用`.in()`批量查询？
- [ ] 我能否使用`Promise.all()`并行查询？
- [ ] 我是否只查询需要的字段？
- [ ] 我是否添加了适当的索引？
- [ ] 我是否使用了React Query缓存？

---

## 🎨 代码模板

### 批量查询模板

```typescript
async function batchQuery<T>(ids: string[]) {
  if (ids.length === 0) return [];
  
  const { data, error } = await supabase
    .from('table_name')
    .select('*')
    .in('id', ids);
    
  if (error) throw error;
  return data;
}
```

### 聚合数据模板

```typescript
function aggregateData<T>(
  items: T[],
  groupBy: keyof T
): Map<any, T[]> {
  const map = new Map();
  
  items.forEach(item => {
    const key = item[groupBy];
    if (!map.has(key)) {
      map.set(key, []);
    }
    map.get(key).push(item);
  });
  
  return map;
}
```

### React Query优化模板

```typescript
const { data } = useQuery({
  queryKey: ['resource', id],
  queryFn: async () => {
    // 批量查询逻辑
    const [main, related] = await Promise.all([
      fetchMain(id),
      fetchRelated(id)
    ]);
    
    return combineData(main, related);
  },
  staleTime: 5 * 60 * 1000,  // 5分钟
  cacheTime: 10 * 60 * 1000  // 10分钟
});
```

---

## 🚨 常见错误

### 错误1: 嵌套循环查询
```typescript
// ❌ 极差的性能
for (const user of users) {
  for (const project of projects) {
    const data = await db.query(...);
  }
}
// 查询次数：N * M（如果N=10, M=20，则200次查询！）
```

### 错误2: 忘记使用索引
```typescript
// ❌ 没有索引的查询
WHERE project_id = '123'

// ✅ 添加索引
CREATE INDEX idx_project_id ON logistics_records(project_id);
```

### 错误3: 查询过多字段
```typescript
// ❌ 查询所有字段
.select('*')

// ✅ 只查询需要的
.select('id, name, status')
```

---

## 📚 相关资源

- [完整优化报告](./数据库查询优化指南.md)
- [数据库索引优化](./数据库性能优化索引.sql)
- [Supabase文档](https://supabase.com/docs)

---

## ✨ 快速总结

1. **避免N+1**: 使用批量查询代替循环查询
2. **并行执行**: 使用`Promise.all()`并行查询
3. **选择字段**: 只查询需要的字段
4. **添加索引**: 为常用查询添加索引
5. **使用缓存**: 利用React Query缓存

**记住**: 每减少一次数据库查询，都能显著提升性能！

---

*快速指南 | 2025年1月8日*

