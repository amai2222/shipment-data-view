# 运单编号统一格式执行指南

## 🎯 目标

将**数据维护**和**运单管理**的Excel导入功能统一使用 `YDN + YYYYMMDD + - + 3位序号` 格式。

---

## 📋 执行步骤

### 第一步：备份数据库（重要！）

在执行任何修改前，请先备份数据库：

```bash
# 在 Supabase Dashboard 中
1. 进入 Settings > Backup
2. 创建手动备份
3. 等待备份完成
```

---

### 第二步：执行SQL迁移

#### 方式1：在 Supabase Dashboard 中执行

1. 登录 [Supabase Dashboard](https://app.supabase.com)
2. 选择您的项目
3. 点击左侧菜单 **SQL Editor**
4. 点击 **New Query**
5. 复制 `supabase/migrations/unify_waybill_number_format.sql` 的内容
6. 粘贴到编辑器中
7. 点击 **Run** 执行

#### 方式2：使用 Supabase CLI

```bash
# 在项目根目录执行
supabase db push

# 或者单独执行这个迁移文件
supabase db execute --file supabase/migrations/unify_waybill_number_format.sql
```

---

### 第三步：验证函数

执行以下SQL验证函数是否正确：

```sql
-- 测试生成运单编号
SELECT public.generate_auto_number('2025-01-08');

-- 预期结果示例：YDN20250108-001
-- （如果当天已有运单，序号会递增）
```

---

### 第四步：测试导入功能

#### 测试数据维护导入

1. 访问：**数据维护 > 运单维护 > 标准导入**
2. 准备测试Excel文件（包含几条测试数据）
3. 导入Excel
4. 检查生成的运单编号格式是否为：`YDN20250108-001`

#### 测试运单管理导入

1. 访问：**运单管理 > 导入Excel**
2. 准备测试Excel文件
3. 导入Excel
4. 检查生成的运单编号格式是否为：`YDN20250108-001`

---

### 第五步：验证现有功能

#### 检查清单

- [ ] 运单列表正常显示（新旧格式都能显示）
- [ ] 运单详情页正常显示编号
- [ ] 搜索功能正常（支持新旧格式搜索）
- [ ] 筛选功能正常
- [ ] 导出Excel功能正常
- [ ] PDF生成功能正常

---

## 🔍 预期结果

### 运单编号格式变化

| 场景 | 修改前 | 修改后 |
|------|--------|--------|
| 数据维护导入 | `202501080001` | `YDN20250108-001` |
| 运单管理导入 | `YDN20250108-001` | `YDN20250108-001` |
| 手动添加运单 | `202501080001` | `YDN20250108-001` |

### 编号示例

```
2025年1月8日：
- 第1条：YDN20250108-001
- 第2条：YDN20250108-002
- 第3条：YDN20250108-003

2025年1月9日：
- 第1条：YDN20250109-001
- 第2条：YDN20250109-002
- 第3条：YDN20250109-003
```

---

## ⚠️ 重要说明

### 1. 现有数据处理

**默认方案（推荐）**：
- ✅ 现有运单编号保持不变
- ✅ 只有新导入的运单使用新格式
- ✅ 系统同时支持新旧两种格式

**迁移方案（可选）**：
如果需要将现有旧格式编号统一转换为新格式，请执行：

```sql
-- 1. 添加备份列
ALTER TABLE public.logistics_records 
ADD COLUMN IF NOT EXISTS old_auto_number TEXT;

-- 2. 转换旧编号为新格式
UPDATE public.logistics_records
SET 
    old_auto_number = auto_number,
    auto_number = 'YDN' || 
                  SUBSTRING(auto_number, 1, 8) || 
                  '-' || 
                  LPAD(SUBSTRING(auto_number, 9)::text, 3, '0')
WHERE auto_number ~ '^\d{11,12}$'  -- 只转换纯数字格式
  AND auto_number NOT LIKE 'YDN%'; -- 排除已是新格式的

-- 3. 验证转换结果
SELECT 
    old_auto_number AS "旧编号",
    auto_number AS "新编号"
FROM public.logistics_records
WHERE old_auto_number IS NOT NULL
LIMIT 10;
```

⚠️ **注意**：执行迁移方案前请务必备份数据库！

### 2. 序号上限

- 新格式每天最多支持 **999** 条运单
- 如果您的业务量超过此限制，请联系开发团队扩展序号位数

### 3. 兼容性

- ✅ 查询功能支持新旧两种格式
- ✅ 筛选功能支持新旧两种格式
- ✅ 导出功能支持新旧两种格式

---

## 🐛 问题排查

### 问题1：编号格式仍然是旧格式

**可能原因**：
- SQL迁移未成功执行
- 函数未正确更新

**解决方法**：
```sql
-- 检查函数定义
SELECT prosrc 
FROM pg_proc 
WHERE proname = 'generate_auto_number';

-- 如果返回的代码中没有 'YDN'，说明函数未更新
-- 重新执行迁移脚本
```

### 问题2：导入时提示编号重复

**可能原因**：
- 并发导入导致序号冲突

**解决方法**：
```sql
-- 查看当天已有的最大序号
SELECT auto_number, loading_date
FROM public.logistics_records
WHERE auto_number LIKE 'YDN' || to_char(CURRENT_DATE, 'YYYYMMDD') || '-%'
ORDER BY auto_number DESC
LIMIT 10;

-- 如果发现重复，可以手动调整
```

### 问题3：序号不连续

**这是正常现象**：
- 导入失败的记录不会占用序号
- 删除的运单不会释放序号

**如需连续序号**：
- 可以批量重新生成编号（需谨慎操作）

---

## 📊 执行时间估算

| 步骤 | 预计时间 |
|------|---------|
| 备份数据库 | 5-10分钟 |
| 执行SQL迁移 | 1-2分钟 |
| 验证函数 | 1分钟 |
| 测试导入功能 | 5-10分钟 |
| 验证现有功能 | 5-10分钟 |
| **总计** | **20-30分钟** |

---

## ✅ 完成确认

执行完成后，请确认以下项目：

- [ ] SQL迁移成功执行，无错误
- [ ] `generate_auto_number` 函数返回新格式编号
- [ ] `import_logistics_data` 函数使用 `generate_auto_number`
- [ ] 数据维护导入生成新格式编号
- [ ] 运单管理导入生成新格式编号
- [ ] 运单列表正常显示
- [ ] 运单详情页正常显示
- [ ] 导出功能正常
- [ ] PDF生成功能正常

---

## 🎉 完成后

### 用户通知

如果您的系统有多个用户，建议发送以下通知：

```
运单编号格式更新通知

尊敬的用户：

系统已升级运单编号格式，新的格式为：YDN20250108-001

变更说明：
1. 新导入的运单将使用新格式编号
2. 现有运单编号不受影响
3. 所有功能正常使用，无需额外操作

如有任何问题，请联系系统管理员。

谢谢！
```

### 文档更新

- 更新用户手册中的运单编号格式说明
- 更新导入模板的使用说明
- 更新培训材料

---

## 📞 技术支持

如果在执行过程中遇到任何问题，请：

1. 检查 Supabase 日志
2. 查看本文档的问题排查部分
3. 保存错误信息截图
4. 联系开发团队

---

## 🔄 回滚方案

如果需要回滚到旧格式，执行以下SQL：

```sql
-- 回滚 generate_auto_number 函数到旧版本
CREATE OR REPLACE FUNCTION public.generate_auto_number(loading_date_input text)
RETURNS text
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $function$
DECLARE
    date_part TEXT;
    next_number INTEGER;
    padded_number TEXT;
BEGIN
    date_part := to_char(to_date(loading_date_input, 'YYYY-MM-DD'), 'YYYYMMDD');
    
    SELECT COALESCE(MAX(CAST(RIGHT(auto_number, 4) AS INTEGER)), 0) + 1
    INTO next_number
    FROM public.logistics_records
    WHERE auto_number LIKE date_part || '%';
    
    padded_number := LPAD(next_number::TEXT, 4, '0');
    
    RETURN date_part || padded_number;
END;
$function$;
```

⚠️ **警告**：回滚后，已生成的新格式编号不会自动转换！

---

**准备好了吗？开始执行吧！** 🚀

---

*执行指南版本：1.0*  
*最后更新：2025年1月8日*
