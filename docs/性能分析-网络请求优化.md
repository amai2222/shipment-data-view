# 网络请求性能分析与优化

## 📊 问题分析

### 观察到的问题

从网络请求截图可以看到：
1. **大量重复的 `profiles` 查询**（30+个相同的请求）
   - 查询相同的用户 ID：`eq.37ba2aea-99a4-491b-8804-08...`
   - 每个请求约 1KB，总计约 30KB+
   - 累计时间：超过 10 秒

2. **get_my_vehicles 查询**
   - 响应时间：570ms

3. **internal_driver_expense_applications 查询**
   - 响应时间：505ms

### 根本原因

**AuthContext 重复查询 profile：**
- `onAuthStateChange` 事件触发多次（SIGNED_IN、TOKEN_REFRESHED 等）
- 每次事件都查询 profile，没有缓存
- 导致大量重复请求

## ✅ 已实施的优化

### 1. AuthContext 缓存优化

**问题：**
```typescript
// 每次认证状态变更都查询 profile
supabase.auth.onAuthStateChange((event, session) => {
  if (currentUser) {
    // 每次都查询！
    const { data: profileData } = await supabase
      .from('profiles')
      .select('*')
      .eq('id', currentUser.id)
      .maybeSingle();
  }
});
```

**优化：**
```typescript
// 使用缓存，避免重复查询
let profileCache: UserProfile | null = null;

supabase.auth.onAuthStateChange((event, session) => {
  // TOKEN_REFRESHED 时直接使用缓存
  if (event === 'TOKEN_REFRESHED') {
    setLoading(false);
    return; // 不查询 profile
  }
  
  // 只在 SIGNED_IN 和 INITIAL_SESSION 时查询
  if (event === 'SIGNED_IN' || event === 'INITIAL_SESSION') {
    // 如果有缓存且用户ID相同，直接使用缓存
    if (profileCache && profileCache.id === currentUser.id) {
      setProfile(profileCache);
      return; // 不查询数据库
    }
    
    // 否则查询并缓存
    const profileData = await query...
    profileCache = userProfile; // 缓存结果
  }
});
```

### 2. 减少预加载请求

**MobileMyExpenses.tsx：**
- 移除 `MobileQuickEntry` 的预加载（避免触发其数据加载）
- 减少预加载数量：6个 → 3个
- 延迟预加载：1秒 → 3秒

**MobileFleetDashboard.tsx：**
- 减少预加载数量：4个 → 2个
- 延迟预加载：1秒 → 3秒

### 3. 资源提示优化

**添加 DNS 预解析和预连接：**
```html
<link rel="dns-prefetch" href="https://mnwzvtvyauyxwowjjsmf.supabase.co">
<link rel="preconnect" href="https://mnwzvtvyauyxwowjjsmf.supabase.co">
```

## 📈 预期效果

### 优化前
- `profiles` 查询：30+ 次
- 总请求时间：~15 秒
- 网络请求数：80+ 个

### 优化后
- `profiles` 查询：1-2 次（减少 90%+）
- 总请求时间：~5 秒（减少 65%）
- 网络请求数：40-50 个（减少 40%）

## 🔍 进一步优化建议

### 1. 使用 React Query 缓存

**当前问题：**
- 每次组件挂载都重新请求数据
- 没有缓存机制

**建议：**
```typescript
// 使用 React Query 缓存用户数据
const { data: profile } = useQuery({
  queryKey: ['user-profile', userId],
  queryFn: () => fetchUserProfile(userId),
  staleTime: 5 * 60 * 1000, // 5分钟内不重新请求
  cacheTime: 10 * 60 * 1000, // 10分钟缓存
});
```

### 2. 批量查询优化

**当前问题：**
- 多个组件各自查询 profile
- N+1 查询问题

**建议：**
- 使用 `BatchQueryService` 批量查询
- 减少数据库往返次数

### 3. 使用 Supabase Realtime 减少轮询

**建议：**
- 订阅数据变更，而不是定时查询
- 减少不必要的网络请求

### 4. 启用 HTTP/2

**建议：**
- 使用 HTTP/2 多路复用
- 减少连接建立时间

## 🧪 验证方法

### 1. 清除缓存测试
```bash
# 清除构建缓存
rm -rf dist node_modules/.vite

# 重新构建
npm run build

# 清除浏览器缓存，硬刷新测试
```

### 2. 使用 Chrome DevTools

**Network 面板检查：**
- 过滤 `profiles` 请求，查看数量
- 查看请求的 Initiator（发起者）
- 检查是否还有重复请求

**Performance 面板检查：**
- 记录页面加载过程
- 分析 Main Thread 阻塞时间
- 查看 Long Tasks

### 3. 对比测试

**测试指标：**
- `profiles` 请求数量
- 总加载时间
- 首屏渲染时间（FCP）
- 可交互时间（TTI）

## 📝 优化检查清单

- [x] ✅ AuthContext profile 缓存
- [x] ✅ 减少预加载数量
- [x] ✅ 延迟预加载时间
- [x] ✅ 添加资源提示
- [x] ✅ 优化 Vite 构建配置
- [ ] ⏳ 使用 React Query 缓存（可选）
- [ ] ⏳ 批量查询优化（可选）
- [ ] ⏳ 启用 HTTP/2（服务器配置）

## 🎯 关键优化效果

### Profile 查询优化
- **优化前**：30+ 次重复查询
- **优化后**：1-2 次查询
- **效果**：减少 90%+ 的 profile 查询，节省 ~10 秒加载时间

### 预加载优化
- **优化前**：首次加载1秒后预加载 6-10 个页面
- **优化后**：首次加载3秒后预加载 2-3 个页面
- **效果**：减少初始网络拥塞，加快主页面加载

### 资源提示优化
- **优化前**：每次请求都需要 DNS 查询
- **优化后**：DNS 预解析，连接预建立
- **效果**：首次 API 请求节省 ~200-500ms

---

**最后更新：** 2025-12-02  
**状态：** ✅ 核心优化已完成  
**预计效果：** 首次加载时间减少 60-70%

