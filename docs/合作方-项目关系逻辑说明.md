# 合作方-项目关系逻辑说明

## 概述

本文档详细说明了系统中合作方（Partners）与项目（Projects）之间的层级关系逻辑，以及如何在各个功能模块中正确使用这些关系。

## 数据库结构

### 核心表结构

```sql
-- 项目表
projects (
  id uuid PRIMARY KEY,
  name text NOT NULL,
  start_date date,
  end_date date,
  manager text,
  loading_address text,
  unloading_address text,
  project_status text
)

-- 合作方表
partners (
  id uuid PRIMARY KEY,
  name text NOT NULL,           -- 合作方简称
  full_name text,               -- 合作方全称
  contact_info jsonb,
  created_at timestamp
)

-- 项目-合作方关系表（核心表）
project_partners (
  id uuid PRIMARY KEY,
  project_id uuid REFERENCES projects(id),
  partner_id uuid REFERENCES partners(id),
  level integer NOT NULL,       -- 层级：数字越大级别越高
  created_at timestamp
)
```

## 层级关系逻辑

### Level字段含义

- **Level = 1**: 最低级别（基础级别）
- **Level = 2, 3, 4, 5...**: 更高级别，数字越大级别越高
- **最高级别**: 每个合作商在特定项目中的最大level值

### 关系示例

```
项目A:
├── 合作方X (level=1)  ← 最低级别
├── 合作方Y (level=2)  ← 中级级别
└── 合作方Z (level=3)  ← 最高级别

项目B:
├── 合作方X (level=2)  ← 中级级别
└── 合作方W (level=4)  ← 最高级别
```

## 前端实现逻辑

### 1. 获取所有项目的最高级合作商

```typescript
// 文件: src/pages/BusinessEntry/components/FilterBar.tsx
const loadPartners = async () => {
  setLoadingPartners(true);
  try {
    // 获取所有项目的合作商，按级别降序排列
    const { data, error } = await supabase
      .from('project_partners')
      .select(`
        partner_id,
        partners (
          id,
          name,           -- 显示简称
          full_name       -- 全称（备用）
        )
      `)
      .order('level', { ascending: false }); // 关键：按级别降序排列
    
    if (error) throw error;
    
    // 智能去重：由于按level降序排列，每个合作商的最高级别记录会先出现
    const uniquePartners = new Map();
    data?.forEach(item => {
      if (item.partners && !uniquePartners.has(item.partners.id)) {
        uniquePartners.set(item.partners.id, item.partners);
      }
    });
    
    setPartners(Array.from(uniquePartners.values()));
  } catch (error) {
    console.error('加载合作商失败:', error);
  } finally {
    setLoadingPartners(false);
  }
};
```

### 2. 根据合作商动态加载项目

```typescript
// 根据合作商加载项目（获取该合作商的所有项目，不限级别）
const loadProjectsByPartner = async (partnerId: string) => {
  if (!partnerId) {
    setPartnerProjects([]);
    return;
  }

  try {
    const { data, error } = await supabase
      .from('project_partners')
      .select(`
        project_id,
        projects (
          id,
          name,
          start_date,
          end_date,
          manager,
          loading_address,
          unloading_address,
          project_status
        )
      `)
      .eq('partner_id', partnerId); // 获取该合作商的所有项目，不限级别

    if (error) throw error;
    
    // 去重并格式化数据
    const uniqueProjects = new Map();
    data?.forEach(item => {
      if (item.projects && !uniqueProjects.has(item.projects.id)) {
        uniqueProjects.set(item.projects.id, item.projects);
      }
    });
    
    setPartnerProjects(Array.from(uniqueProjects.values()));
  } catch (error) {
    console.error('加载合作商项目失败:', error);
    setPartnerProjects([]);
  }
};
```

### 3. 合作商选择变化处理

```typescript
// 合作商选择变化
const handlePartnerChange = (partnerId: string) => {
  setSelectedPartnerId(partnerId);
  handleInputChange('projectName', ''); // 清空项目选择
  // 不更新合作商筛选，只用于动态加载项目
  loadProjectsByPartner(partnerId);
};
```

## 数据库查询模式

### 1. 获取最高级合作商（SQL）

```sql
-- 方法1：使用窗口函数（推荐）
SELECT DISTINCT ON (partner_id) 
  partner_id,
  partners.name,
  partners.full_name,
  level
FROM project_partners pp
JOIN partners ON pp.partner_id = partners.id
ORDER BY partner_id, level DESC;

-- 方法2：使用子查询
SELECT pp.partner_id, p.name, p.full_name, pp.level
FROM project_partners pp
JOIN partners p ON pp.partner_id = p.id
WHERE pp.level = (
  SELECT MAX(level) 
  FROM project_partners pp2 
  WHERE pp2.partner_id = pp.partner_id
);
```

### 2. 获取合作商的所有项目

```sql
-- 获取指定合作商的所有项目
SELECT DISTINCT 
  p.id,
  p.name,
  p.start_date,
  p.end_date,
  p.manager,
  p.loading_address,
  p.unloading_address,
  p.project_status
FROM projects p
JOIN project_partners pp ON p.id = pp.project_id
WHERE pp.partner_id = $1;
```

### 3. 获取项目的所有合作商（按级别排序）

```sql
-- 获取指定项目的所有合作商，按级别降序排列
SELECT 
  pp.level,
  p.id,
  p.name,
  p.full_name
FROM project_partners pp
JOIN partners p ON pp.partner_id = p.id
WHERE pp.project_id = $1
ORDER BY pp.level DESC;
```

## 使用场景

### 1. 筛选器场景

- **合作商筛选器**: 显示所有项目的最高级合作商
- **项目筛选器**: 根据选择的合作商动态显示项目
- **层级筛选**: 可以按合作商级别进行筛选

### 2. 数据展示场景

- **项目详情**: 显示项目的所有合作商及其级别
- **合作商详情**: 显示合作商参与的所有项目
- **层级关系图**: 可视化展示合作商-项目关系

### 3. 权限控制场景

- **级别权限**: 根据合作商级别控制功能访问
- **项目权限**: 根据合作商与项目的关系控制数据访问
- **操作权限**: 不同级别的合作商有不同的操作权限

## 最佳实践

### 1. 前端实现

- ✅ **按级别降序排列**: 确保最高级别记录先出现
- ✅ **智能去重**: 使用Map确保每个合作商只显示一次
- ✅ **动态加载**: 选择合作商后动态加载相关项目
- ✅ **显示简称**: 下拉列表显示合作商简称，避免冗长全称

### 2. 数据库查询

- ✅ **使用DISTINCT ON**: PostgreSQL的DISTINCT ON适合获取每组的第一条记录
- ✅ **合理使用索引**: 在project_id, partner_id, level字段上建立索引
- ✅ **避免N+1查询**: 使用JOIN一次性获取相关数据

### 3. 性能优化

- ✅ **缓存机制**: 合作商列表可以缓存，减少重复查询
- ✅ **分页加载**: 大量数据时使用分页加载
- ✅ **懒加载**: 项目列表按需加载

## 常见问题

### Q1: 为什么有些合作商没有显示？

**A**: 检查是否使用了全局最高级别筛选。应该获取所有合作商，然后按级别去重。

### Q2: 如何获取合作商在特定项目中的级别？

**A**: 查询project_partners表，WHERE project_id = ? AND partner_id = ?

### Q3: 如何判断合作商是否为最高级别？

**A**: 比较合作商的level值与该项目中所有合作商的最大level值。

## 扩展功能

### 1. 层级管理

- 支持动态调整合作商级别
- 级别变更历史记录
- 级别变更审批流程

### 2. 关系分析

- 合作商-项目关系矩阵
- 级别分布统计
- 关系强度分析

### 3. 权限集成

- 基于级别的功能权限
- 基于关系的数据权限
- 动态权限计算

---

**最后更新**: 2024年12月
**维护者**: 开发团队
**版本**: v1.0
