# 合作方-项目关系逻辑说明

## 概述

本文档详细说明了系统中合作方（Partners）与项目（Projects）之间的层级关系逻辑，以及如何在各个功能模块中正确使用这些关系。

## 数据库结构

### 核心表结构

```sql
-- 项目表
projects (
  id uuid PRIMARY KEY,
  name text NOT NULL,
  start_date date,
  end_date date,
  manager text,
  loading_address text,
  unloading_address text,
  project_status text
)

-- 合作方表
partners (
  id uuid PRIMARY KEY,
  name text NOT NULL,           -- 合作方简称
  full_name text,               -- 合作方全称
  contact_info jsonb,
  created_at timestamp
)

-- 项目-合作方关系表（核心表）
project_partners (
  id uuid PRIMARY KEY,
  project_id uuid REFERENCES projects(id),
  partner_id uuid REFERENCES partners(id),
  level integer NOT NULL,       -- 层级：数字越大级别越高
  created_at timestamp
)
```

## 层级关系逻辑

### Level字段含义

- **Level = 1**: 最低级别（基础级别）
- **Level = 2, 3, 4, 5...**: 更高级别，数字越大级别越高
- **最高级别**: 每个合作商在特定项目中的最大level值

### 关系示例

```
项目A:
├── 合作方X (level=1)  ← 最低级别
├── 合作方Y (level=2)  ← 中级级别
└── 合作方Z (level=3)  ← 最高级别

项目B:
├── 合作方X (level=2)  ← 中级级别
└── 合作方W (level=4)  ← 最高级别
```

## 前端实现逻辑

### 1. 获取每个项目的最高级合作商

```typescript
// 文件: src/pages/BusinessEntry/components/FilterBar.tsx
const loadPartners = async () => {
  setLoadingPartners(true);
  try {
    // 首先检查partners表是否有数据
    const { data: partnersData, error: partnersError } = await supabase
      .from('partners')
      .select('id, name, full_name')
      .order('name');
    
    if (partnersError) throw partnersError;
    
    // 然后检查project_partners表是否有数据
    const { data: projectPartnersData, error: projectPartnersError } = await supabase
      .from('project_partners')
      .select(`
        partner_id,
        project_id,
        level,
        partners (
          id,
          name,
          full_name
        )
      `)
      .order('level', { ascending: false });
    
    if (projectPartnersError) {
      // 如果project_partners表没有数据，使用partners表的数据
      setPartners(partnersData || []);
      return;
    }
    
    if (!projectPartnersData || projectPartnersData.length === 0) {
      // 如果project_partners表为空，使用partners表的数据
      setPartners(partnersData || []);
      return;
    }
    
    // 按项目分组，找到每个项目的最高级别合作商
    const projectMaxLevels = new Map();
    projectPartnersData.forEach(item => {
      if (item.project_id) {
        const currentMax = projectMaxLevels.get(item.project_id) || 0;
        if (item.level > currentMax) {
          projectMaxLevels.set(item.project_id, item.level);
        }
      }
    });
    
    // 获取每个项目最高级别的合作商
    const highestLevelPartners = new Map();
    projectPartnersData.forEach(item => {
      if (item.project_id && item.partners) {
        const projectMaxLevel = projectMaxLevels.get(item.project_id);
        if (item.level === projectMaxLevel) {
          // 使用合作商ID作为key（确保每个合作商实体只显示一次）
          if (!highestLevelPartners.has(item.partners.id)) {
            highestLevelPartners.set(item.partners.id, {
              id: item.partners.id,
              name: item.partners.name,  // 使用简称
              full_name: item.partners.full_name
            });
          }
        }
      }
    });
    
    const partnersArray = Array.from(highestLevelPartners.values());
    setPartners(partnersArray);
    
  } catch (error) {
    console.error('加载合作商失败:', error);
  } finally {
    setLoadingPartners(false);
  }
};
```

### 2. 根据合作商动态加载项目

```typescript
// 根据合作商加载项目（获取该合作商的所有项目，不限级别）
const loadProjectsByPartner = async (partnerId: string) => {
  if (!partnerId) {
    setPartnerProjects([]);
    return;
  }

  try {
    const { data, error } = await supabase
      .from('project_partners')
      .select(`
        project_id,
        projects (
          id,
          name,
          start_date,
          end_date,
          manager,
          loading_address,
          unloading_address,
          project_status
        )
      `)
      .eq('partner_id', partnerId); // 获取该合作商的所有项目，不限级别

    if (error) throw error;
    
    // 去重并格式化数据
    const uniqueProjects = new Map();
    data?.forEach(item => {
      if (item.projects && !uniqueProjects.has(item.projects.id)) {
        uniqueProjects.set(item.projects.id, item.projects);
      }
    });
    
    setPartnerProjects(Array.from(uniqueProjects.values()));
  } catch (error) {
    console.error('加载合作商项目失败:', error);
    setPartnerProjects([]);
  }
};
```

### 3. 合作商选择变化处理

```typescript
// 合作商选择变化
const handlePartnerChange = (partnerId: string) => {
  setSelectedPartnerId(partnerId);
  handleInputChange('projectName', ''); // 清空项目选择
  // 不更新合作商筛选，只用于动态加载项目
  loadProjectsByPartner(partnerId);
};
```

## 数据库查询模式

### 1. 获取每个项目的最高级合作商（SQL）

```sql
-- 方法1：使用窗口函数（推荐）
WITH project_max_levels AS (
  SELECT 
    project_id,
    MAX(level) as max_level
  FROM project_partners
  GROUP BY project_id
),
highest_level_partners AS (
  SELECT DISTINCT
    pp.partner_id,
    p.name,
    p.full_name,
    pp.level
  FROM project_partners pp
  JOIN partners p ON pp.partner_id = p.id
  JOIN project_max_levels pml ON pp.project_id = pml.project_id
  WHERE pp.level = pml.max_level
)
SELECT * FROM highest_level_partners ORDER BY name;

-- 方法2：使用子查询
SELECT DISTINCT
  pp.partner_id,
  p.name,
  p.full_name,
  pp.level
FROM project_partners pp
JOIN partners p ON pp.partner_id = p.id
WHERE pp.level = (
  SELECT MAX(level) 
  FROM project_partners pp2 
  WHERE pp2.project_id = pp.project_id
)
ORDER BY p.name;
```

### 2. 获取合作商的所有项目

```sql
-- 获取指定合作商的所有项目
SELECT DISTINCT 
  p.id,
  p.name,
  p.start_date,
  p.end_date,
  p.manager,
  p.loading_address,
  p.unloading_address,
  p.project_status
FROM projects p
JOIN project_partners pp ON p.id = pp.project_id
WHERE pp.partner_id = $1;
```

### 3. 获取项目的所有合作商（按级别排序）

```sql
-- 获取指定项目的所有合作商，按级别降序排列
SELECT 
  pp.level,
  p.id,
  p.name,
  p.full_name
FROM project_partners pp
JOIN partners p ON pp.partner_id = p.id
WHERE pp.project_id = $1
ORDER BY pp.level DESC;
```

## 使用场景

### 1. 筛选器场景

- **合作商筛选器**: 显示所有项目的最高级合作商
- **项目筛选器**: 根据选择的合作商动态显示项目
- **层级筛选**: 可以按合作商级别进行筛选

### 2. 数据展示场景

- **项目详情**: 显示项目的所有合作商及其级别
- **合作商详情**: 显示合作商参与的所有项目
- **层级关系图**: 可视化展示合作商-项目关系

### 3. 权限控制场景

- **级别权限**: 根据合作商级别控制功能访问
- **项目权限**: 根据合作商与项目的关系控制数据访问
- **操作权限**: 不同级别的合作商有不同的操作权限

## 最佳实践

### 1. 前端实现

- ✅ **按项目分组**: 找到每个项目的最高级别，而不是全局最高级别
- ✅ **智能去重**: 使用Map确保每个合作商实体只显示一次
- ✅ **动态加载**: 选择合作商后动态加载相关项目
- ✅ **显示简称**: 下拉列表显示合作商简称，避免冗长全称
- ✅ **错误处理**: 当project_partners表为空时，回退到partners表
- ✅ **调试信息**: 添加详细的console.log帮助诊断问题

### 2. 数据库查询

- ✅ **使用CTE**: 使用WITH子句提高查询可读性
- ✅ **合理使用索引**: 在project_id, partner_id, level字段上建立索引
- ✅ **避免N+1查询**: 使用JOIN一次性获取相关数据
- ✅ **按项目分组**: 使用GROUP BY找到每个项目的最高级别

### 3. 性能优化

- ✅ **缓存机制**: 合作商列表可以缓存，减少重复查询
- ✅ **分页加载**: 大量数据时使用分页加载
- ✅ **懒加载**: 项目列表按需加载
- ✅ **智能回退**: 当关系表为空时，使用基础表数据

## 常见问题

### Q1: 为什么有些合作商没有显示？

**A**: 检查是否使用了全局最高级别筛选。应该按项目分组，找到每个项目的最高级别合作商。

### Q2: 如何获取合作商在特定项目中的级别？

**A**: 查询project_partners表，WHERE project_id = ? AND partner_id = ?

### Q3: 如何判断合作商是否为项目中的最高级别？

**A**: 比较合作商的level值与该项目中所有合作商的最大level值。

### Q4: 如果project_partners表为空怎么办？

**A**: 系统会自动回退到partners表，显示所有合作商。

### Q5: 如何确保合作商去重正确？

**A**: 使用合作商ID作为Map的key，确保每个合作商实体只显示一次。

## 扩展功能

### 1. 层级管理

- 支持动态调整合作商级别
- 级别变更历史记录
- 级别变更审批流程

### 2. 关系分析

- 合作商-项目关系矩阵
- 级别分布统计
- 关系强度分析

### 3. 权限集成

- 基于级别的功能权限
- 基于关系的数据权限
- 动态权限计算

---

**最后更新**: 2024年12月
**维护者**: 开发团队
**版本**: v1.0
