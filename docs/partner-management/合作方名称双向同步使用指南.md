# 合作方名称双向同步使用指南

## 🎯 功能说明

实现了 `partners` 表和 `partner_bank_details` 表之间 `full_name` 字段的**双向自动同步**。

### ✅ 同步机制
- **partners.full_name** 更新 → 自动同步到 **partner_bank_details.full_name**
- **partner_bank_details.full_name** 更新 → 自动同步到 **partners.full_name**
- **实时同步**：任何一方的修改都会立即同步到另一方

## 🔧 技术实现

### 1. 数据库触发器
```sql
-- partners表触发器
CREATE TRIGGER trigger_sync_partner_to_bank_details
    AFTER INSERT OR UPDATE OF full_name ON public.partners
    FOR EACH ROW
    EXECUTE FUNCTION public.sync_partner_to_bank_details();

-- partner_bank_details表触发器  
CREATE TRIGGER trigger_sync_bank_details_to_partner
    AFTER INSERT OR UPDATE OF full_name ON public.partner_bank_details
    FOR EACH ROW
    EXECUTE FUNCTION public.sync_bank_details_to_partner();
```

### 2. 同步函数
- `sync_partner_to_bank_details()` - partners → partner_bank_details
- `sync_bank_details_to_partner()` - partner_bank_details → partners

## 📋 使用方法

### 1. 自动同步（推荐）
**无需任何操作**，系统会自动处理：
- 在合作方管理页面修改 `full_name` → 自动同步到银行详情
- 在银行详情页面修改 `full_name` → 自动同步到合作方信息

### 2. 手动检查数据一致性
```sql
-- 检查所有合作方的一致性
SELECT * FROM public.check_partner_name_consistency();

-- 只查看不一致的记录
SELECT * FROM public.check_partner_name_consistency() 
WHERE NOT is_consistent;
```

### 3. 手动修复数据
```sql
-- 修复所有不一致的记录
SELECT * FROM public.fix_partner_name_consistency();

-- 手动同步单个合作方
SELECT public.sync_partner_names_manual('合作方ID');

-- 批量同步所有合作方
SELECT public.sync_all_partner_names();
```

## 🎨 前端使用示例

### 1. 合作方管理页面
```typescript
// 修改合作方full_name时，会自动同步到partner_bank_details
const updatePartner = async (partnerId: string, fullName: string) => {
  const { error } = await supabase
    .from('partners')
    .update({ full_name: fullName })
    .eq('id', partnerId);
  
  // 无需手动更新partner_bank_details，触发器会自动处理
  if (error) throw error;
};
```

### 2. 银行详情页面
```typescript
// 修改银行详情full_name时，会自动同步到partners
const updateBankDetails = async (partnerId: string, fullName: string) => {
  const { error } = await supabase
    .from('partner_bank_details')
    .update({ full_name: fullName })
    .eq('partner_id', partnerId);
  
  // 无需手动更新partners，触发器会自动处理
  if (error) throw error;
};
```

## 🔍 数据验证

### 1. 检查同步状态
```sql
-- 查看所有合作方的同步状态
SELECT 
    p.id,
    p.name,
    p.full_name as partners_full_name,
    pbd.full_name as bank_full_name,
    CASE 
        WHEN p.full_name = pbd.full_name THEN '✅ 已同步'
        WHEN p.full_name IS NULL AND pbd.full_name IS NULL THEN '✅ 都为空'
        ELSE '❌ 不一致'
    END as sync_status
FROM public.partners p
LEFT JOIN public.partner_bank_details pbd ON p.id = pbd.partner_id
WHERE pbd.partner_id IS NOT NULL;
```

### 2. 监控同步日志
```sql
-- 查看同步操作日志（需要启用日志记录）
SELECT * FROM pg_stat_activity 
WHERE query LIKE '%sync_partner%' 
OR query LIKE '%sync_bank%';
```

## ⚠️ 注意事项

### 1. 数据优先级
- **partners.full_name** 优先于 **partner_bank_details.full_name**
- 如果两个字段都有值且不同，以 partners 表为准

### 2. 性能考虑
- 触发器是异步执行的，不会阻塞主操作
- 大量数据修改时建议使用批量同步函数

### 3. 错误处理
- 如果同步失败，会在数据库日志中记录错误
- 可以使用手动同步函数进行修复

## 🛠️ 故障排除

### 1. 同步不生效
```sql
-- 检查触发器是否存在
SELECT trigger_name, event_object_table 
FROM information_schema.triggers 
WHERE event_object_table IN ('partners', 'partner_bank_details');

-- 重新创建触发器
DROP TRIGGER IF EXISTS trigger_sync_partner_to_bank_details ON public.partners;
DROP TRIGGER IF EXISTS trigger_sync_bank_details_to_partner ON public.partner_bank_details;
-- 然后重新执行创建触发器的SQL
```

### 2. 数据不一致
```sql
-- 强制同步所有数据
SELECT public.sync_all_partner_names();
```

### 3. 性能问题
```sql
-- 检查触发器执行时间
SELECT * FROM pg_stat_user_functions 
WHERE funcname LIKE '%sync_partner%';
```

## 📊 监控和维护

### 1. 定期检查
```sql
-- 每周检查一次数据一致性
SELECT 
    COUNT(*) as total_records,
    COUNT(CASE WHEN is_consistent THEN 1 END) as consistent_count,
    COUNT(CASE WHEN NOT is_consistent THEN 1 END) as inconsistent_count
FROM public.check_partner_name_consistency();
```

### 2. 性能监控
```sql
-- 监控触发器执行情况
SELECT 
    schemaname,
    tablename,
    n_tup_ins as inserts,
    n_tup_upd as updates,
    n_tup_del as deletes
FROM pg_stat_user_tables 
WHERE tablename IN ('partners', 'partner_bank_details');
```

## 🎉 总结

通过这个双向同步方案，您可以：

1. **自动同步**：修改任一表的 `full_name` 都会自动同步到另一表
2. **数据一致性**：确保两个表的 `full_name` 字段始终保持一致
3. **实时更新**：所有相关页面和报表都会显示最新的名称
4. **易于维护**：提供完整的检查、修复和监控工具

**现在您可以放心地在合作方管理中修改 `full_name`，系统会自动处理所有相关的数据同步！** 🚀
