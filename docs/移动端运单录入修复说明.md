# 移动端运单录入修复说明

## 📋 问题描述

移动端的运单录入逻辑存在以下问题：

1. **新增运单**：直接插入到 `logistics_records` 表，没有自动计算合作方成本
2. **编辑运单**：直接更新 `logistics_records` 表，没有重新计算合作方成本
3. **缺少有效数量类型支持**：没有使用项目配置的有效数量计算方式

## 🔧 修复内容

### 1. 新增运单逻辑修复

**修复前**：
```typescript
// 直接插入到 logistics_records 表
const { error } = await supabase
  .from('logistics_records')
  .insert({
    auto_number: autoNumber,
    project_id: formData.projectId,
    // ... 其他字段
  });
```

**修复后**：
```typescript
// 使用数据库函数来添加运单并自动计算合作方成本
const { error } = await supabase.rpc('add_logistics_record_with_costs', {
  p_project_id: formData.projectId,
  p_project_name: projects.find(p => p.id === formData.projectId)?.name || '',
  p_chain_id: formData.chainId,
  p_driver_id: formData.driverId,
  p_driver_name: drivers.find(d => d.id === formData.driverId)?.name || '',
  p_loading_location: locations.find(l => l.id === formData.loadingLocationId)?.name || '',
  p_unloading_location: locations.find(l => l.id === formData.unloadingLocationId)?.name || '',
  p_loading_date: formData.loadingDate?.toISOString().split('T')[0] || '',
  p_loading_weight: parseFloat(formData.loading_weight) || 0,
  p_unloading_weight: parseFloat(formData.unloading_weight) || 0,
  p_current_cost: parseFloat(formData.currentCost) || 0,
  p_license_plate: formData.licensePlate,
  p_driver_phone: formData.driverPhone,
  p_transport_type: formData.transportType,
  p_extra_cost: parseFloat(formData.extraCost) || 0,
  p_remarks: formData.remarks,
  p_unloading_date: formData.unloadingDate?.toISOString().split('T')[0] || ''
});
```

### 2. 编辑运单逻辑修复

**修复前**：
```typescript
// 直接更新 logistics_records 表
const { error } = await supabase
  .from('logistics_records')
  .update({
    project_id: formData.projectId,
    // ... 其他字段
  })
  .eq('id', id);
```

**修复后**：
```typescript
// 使用数据库函数来更新运单并重新计算合作方成本
const { error } = await supabase.rpc('update_logistics_record_via_recalc', {
  p_record_id: id,
  p_project_id: formData.projectId,
  p_project_name: projects.find(p => p.id === formData.projectId)?.name || '',
  p_chain_id: formData.chainId,
  p_driver_id: formData.driverId,
  p_driver_name: drivers.find(d => d.id === formData.driverId)?.name || '',
  p_loading_location: locations.find(l => l.id === formData.loadingLocationId)?.name || '',
  p_unloading_location: locations.find(l => l.id === formData.unloadingLocationId)?.name || '',
  p_loading_date: formData.loadingDate?.toISOString() || '',
  p_loading_weight: parseFloat(formData.loading_weight) || 0,
  p_unloading_weight: parseFloat(formData.unloading_weight) || 0,
  p_current_cost: parseFloat(formData.currentCost) || 0,
  p_license_plate: formData.licensePlate,
  p_driver_phone: formData.driverPhone,
  p_transport_type: formData.transportType,
  p_extra_cost: parseFloat(formData.extraCost) || 0,
  p_remarks: formData.remarks,
  p_unloading_date: formData.unloadingDate?.toISOString() || ''
});
```

## ✅ 修复效果

### 1. 自动计算合作方成本
- 新增运单后自动计算所有合作方的应付款
- 编辑运单后自动重新计算合作方成本
- 确保数据一致性

### 2. 支持有效数量类型
- 使用项目配置的有效数量计算方式
- 支持三种计算方式：取较小值、取装货数量、取卸货数量
- 与桌面端逻辑保持一致

### 3. 数据完整性
- 自动生成运单编号
- 自动计算司机应收金额
- 自动关联合作方成本记录

## 🔄 相关数据库函数

移动端现在使用以下数据库函数：

1. **`add_logistics_record_with_costs`** - 新增运单并计算成本
2. **`update_logistics_record_via_recalc`** - 更新运单并重新计算成本
3. **`calculate_effective_quantity`** - 计算有效数量
4. **`recalculate_and_update_costs_for_record`** - 重新计算单个记录的成本

## 📱 移动端特性

### 1. 用户界面
- 保持原有的移动端界面设计
- 用户体验不变
- 操作流程保持一致

### 2. 数据同步
- 与桌面端数据完全同步
- 实时计算合作方成本
- 支持多端数据一致性

### 3. 性能优化
- 使用数据库函数减少网络请求
- 批量计算提高效率
- 减少前端计算负担

## 🎯 测试验证

修复完成后，请测试以下场景：

1. **新增运单**：
   - 在移动端新增运单
   - 检查是否自动计算合作方成本
   - 验证有效数量计算是否正确

2. **编辑运单**：
   - 在移动端编辑运单
   - 检查是否重新计算合作方成本
   - 验证数据更新是否正确

3. **数据一致性**：
   - 移动端和桌面端数据是否一致
   - 运费对账页面是否正确显示
   - 合作方成本计算是否准确

## 📝 注意事项

1. **向后兼容**：修复不影响现有数据
2. **错误处理**：保持原有的错误处理逻辑
3. **用户体验**：界面和操作流程保持不变
4. **数据安全**：使用数据库函数确保数据完整性

现在移动端的运单录入逻辑已经与桌面端完全一致，支持项目配置的有效数量类型，并自动计算合作方成本！
