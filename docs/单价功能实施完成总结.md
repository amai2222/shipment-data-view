# 单价功能实施完成总结

## ✅ 已完成的工作

### 1. 前端实现 ✅

#### 文件修改：
- `src/pages/BusinessEntry/components/LogisticsFormDialog.tsx`
- `src/pages/BusinessEntry/types.ts`

#### 功能点：
- ✅ 添加单价输入框（`unit_price`）
- ✅ 实现自动/手动模式切换逻辑
- ✅ 根据项目配置计算有效数量
- ✅ 自动计算运费（auto 模式）
- ✅ UI 优化（模式标识、只读样式、计算公式显示）
- ✅ 新增和编辑运单都支持单价功能

### 2. 数据库实现 ✅

#### 迁移文件：
1. `supabase/migrations/20251120_add_unit_price_and_auto_calculation.sql`
   - 添加 `unit_price`、`effective_quantity`、`calculation_mode` 字段
   - 创建 `get_effective_quantity_for_record` 函数
   - 创建 `auto_calculate_cost_from_unit_price` 触发器函数
   - 创建触发器

2. `supabase/migrations/20251120_update_rpc_functions_support_unit_price.sql`
   - 更新 `update_logistics_record_via_recalc` 函数

3. `supabase/migrations/20251116_fix_add_logistics_record_with_costs_date_type.sql`（已更新）
   - 更新 `add_logistics_record_with_costs` 函数，添加 `p_unit_price` 参数

#### 功能点：
- ✅ 新增 3 个数据库字段
- ✅ 创建有效数量计算函数（复用项目配置）
- ✅ 创建自动计算触发器
- ✅ 更新 RPC 函数支持单价参数
- ✅ 旧数据自动设置为手动模式

---

## 🎯 核心功能

### 计算逻辑流程

```
用户输入单价
    ↓
触发器判断：有单价？
    ├─ 是 → calculation_mode = 'auto'
    │   ↓
    │   1. 读取项目的 effective_quantity_type 配置
    │   2. 调用 get_effective_quantity_for_record() 计算有效数量
    │   3. current_cost = unit_price × effective_quantity
    │   4. payable_cost = current_cost + extra_cost
    │
    └─ 否 → calculation_mode = 'manual'
        ↓
        1. 计算有效数量（仅用于记录）
        2. current_cost = 用户输入
        3. payable_cost = current_cost + extra_cost
```

### 项目配置驱动

有效数量根据 `projects.effective_quantity_type` 自动计算：

| 配置 | 计算方式 | 示例（装货20吨，卸货19.8吨） |
|------|---------|----------------------------|
| `min_value` | 取较小值 | 19.8 吨 |
| `loading` | 取装货数量 | 20 吨 |
| `unloading` | 取卸货数量 | 19.8 吨 |

---

## 📊 数据库字段

### 新增字段

| 字段名 | 类型 | 允许NULL | 默认值 | 说明 |
|--------|------|----------|--------|------|
| `unit_price` | NUMERIC(10,2) | YES | NULL | 单价（元/吨） |
| `effective_quantity` | NUMERIC(10,3) | YES | NULL | 有效数量（吨），根据项目配置自动计算 |
| `calculation_mode` | TEXT | NO | 'manual' | 计算模式：'manual' 或 'auto' |

### 约束和索引

```sql
-- 约束
CHECK (calculation_mode IN ('manual', 'auto'))

-- 索引
CREATE INDEX idx_logistics_records_unit_price 
ON logistics_records(unit_price) WHERE unit_price IS NOT NULL;
```

---

## 🔧 数据库函数

### 1. get_effective_quantity_for_record

**功能**：根据项目配置计算有效数量

**参数**：
- `p_loading_weight`：装货重量
- `p_unloading_weight`：卸货重量
- `p_project_id`：项目ID

**返回**：有效数量（NUMERIC）

**逻辑**：
```sql
1. 查询项目的 effective_quantity_type 配置
2. 根据配置计算：
   - 'loading' → 返回装货重量
   - 'unloading' → 返回卸货重量
   - 'min_value' → 返回较小值
```

### 2. auto_calculate_cost_from_unit_price

**功能**：自动计算运费的触发器函数

**触发时机**：
- INSERT
- UPDATE OF unit_price, loading_weight, unloading_weight, extra_cost

**逻辑**：
```sql
1. 判断是否有单价
   - 有 → calculation_mode = 'auto'
   - 无 → calculation_mode = 'manual'

2. auto 模式：
   - 计算有效数量
   - 计算运费：unit_price × effective_quantity
   - 计算应付：current_cost + extra_cost

3. manual 模式：
   - 计算有效数量（仅记录）
   - 计算应付：current_cost + extra_cost
```

### 3. add_logistics_record_with_costs（已更新）

**新增参数**：
- `p_unit_price NUMERIC DEFAULT NULL`

**调用示例**：
```javascript
await supabase.rpc('add_logistics_record_with_costs', {
  // ... 其他参数
  p_unit_price: 350, // 单价
  // ...
});
```

### 4. update_logistics_record_via_recalc（已更新）

**新增参数**：
- `p_unit_price NUMERIC DEFAULT NULL`

**调用示例**：
```javascript
await supabase.rpc('update_logistics_record_via_recalc', {
  // ... 其他参数
  p_unit_price: 350, // 单价
  // ...
});
```

---

## 🔄 完整数据流

### 新增运单（auto 模式）

```
前端:
  用户输入单价 = 350 元/吨
  用户输入装货重量 = 20 吨
  用户输入卸货重量 = 19.8 吨
    ↓
  前端实时计算预览:
    effective_quantity = 19.8 吨（根据项目配置）
    current_cost = 350 × 19.8 = 6930 元
    ↓
  提交到后端:
    p_unit_price = 350
    p_current_cost = 6930（前端计算的）
    p_loading_weight = 20
    p_unloading_weight = 19.8
    ↓
后端:
  RPC 函数 add_logistics_record_with_costs 插入数据
    ↓
  触发器 auto_calculate_cost_from_unit_price 执行:
    1. 判断有单价 → calculation_mode = 'auto'
    2. 调用 get_effective_quantity_for_record
       → effective_quantity = 19.8
    3. 重新计算 current_cost = 350 × 19.8 = 6930
    4. 计算 payable_cost = 6930 + extra_cost
    ↓
  触发器 trigger_recalc_on_payable_cost_change 执行:
    重新计算所有合作方成本（基于 payable_cost）
    ↓
数据库:
  运单保存成功，合作方成本已计算
```

### 编辑运单（切换到 auto 模式）

```
前端:
  用户输入单价 = 360 元/吨（原来为空）
  装货重量 = 20 吨
  卸货重量 = 19.8 吨
    ↓
  前端实时计算:
    current_cost = 360 × 19.8 = 7128 元
    ↓
  提交到后端:
    p_unit_price = 360
    ↓
后端:
  RPC 函数 update_logistics_record_via_recalc 更新数据
    ↓
  触发器自动计算:
    1. calculation_mode = 'auto'
    2. effective_quantity = 19.8
    3. current_cost = 360 × 19.8 = 7128
    4. payable_cost = 7128 + extra_cost
    ↓
  重算合作方成本
```

---

## 🛡️ 向后兼容验证

### 旧数据处理

```sql
-- 迁移后，旧数据：
UPDATE logistics_records
SET 
    calculation_mode = 'manual',  -- 设置为手动模式
    effective_quantity = ...      -- 填充有效数量（仅记录）
WHERE calculation_mode IS NULL;
```

### 旧数据不变

| 字段 | 迁移前 | 迁移后 | 说明 |
|------|-------|-------|------|
| `unit_price` | - | NULL | 新增字段，为空 |
| `effective_quantity` | - | 19.8 | 新增字段，自动填充 |
| `calculation_mode` | - | 'manual' | 新增字段，默认手动 |
| `current_cost` | 7000 | 7000 | ✅ 不变 |
| `payable_cost` | 7100 | 7100 | ✅ 不变 |

---

## 📋 部署步骤

### 1. 执行数据库迁移（按顺序）

```sql
-- 第一步：添加字段和触发器
执行: supabase/migrations/20251120_add_unit_price_and_auto_calculation.sql

-- 第二步：更新 RPC 函数
执行: supabase/migrations/20251120_update_rpc_functions_support_unit_price.sql

-- 第三步：更新 add_logistics_record_with_costs 函数
重新执行: supabase/migrations/20251116_fix_add_logistics_record_with_costs_date_type.sql
```

### 2. 前端部署

```bash
# 无需额外操作，刷新页面即可
```

### 3. 验证测试

- [ ] 新增运单（手动模式）
- [ ] 新增运单（自动模式）
- [ ] 编辑旧运单（保持手动模式）
- [ ] 编辑旧运单（切换到自动模式）
- [ ] 验证合作方成本重算

---

## 🎉 功能演示

### 自动模式示例

**用户操作**：
1. 选择项目：测试项目（配置：取较小值）
2. 输入单价：350 元/吨
3. 输入装货重量：20 吨
4. 输入卸货重量：19.8 吨
5. 输入额外费用：100 元

**系统计算**：
```
有效数量 = MIN(20, 19.8) = 19.8 吨
运费 = 350 × 19.8 = 6,930.00 元
司机应收 = 6,930 + 100 = 7,030.00 元
```

**界面显示**：
```
费用信息                     [自动计算模式]
┌─────────────────────────────────────────┐
│ 单价（元/吨）                            │
│ [  350  ]                               │
│ 💡 已输入单价，运费将自动计算             │
├─────────────────────────────────────────┤
│ 有效数量（吨）                           │
│ [ 19.800 ] (只读)                       │
│ 📦 按项目配置：取装货和卸货较小值         │
├─────────────────────────────────────────┤
│ 运费(元) * (自动计算)   │  额外费(元)   │
│ [ 6930.00 ] (只读)      │  [ 100 ]      │
│ 计算：350 × 19.800 = 6930                │
└─────────────────────────────────────────┘

司机应收金额
┌─────────────────────────────────────────┐
│          ¥7,030.00                      │
│     自动计算：运费 + 额外费              │
└─────────────────────────────────────────┘
```

---

## ⚠️ 注意事项

### 1. 迁移顺序很重要

必须按顺序执行：
1. ✅ 先执行添加字段和触发器
2. ✅ 再执行更新 RPC 函数
3. ✅ 最后重新执行更新的函数

### 2. 触发器依赖

- `auto_calculate_cost_from_unit_price` 触发器依赖 `get_effective_quantity_for_record` 函数
- 必须先创建函数，再创建触发器

### 3. 项目配置

- 确保所有项目都有 `effective_quantity_type` 配置
- 如果没有配置，会使用默认值 `'min_value'`

### 4. 前端刷新

- 执行完数据库迁移后，刷新前端页面
- 清除浏览器缓存（如果遇到问题）

---

## 📝 测试清单

### 基础功能测试

- [ ] **新增运单 - 手动模式**
  - 不输入单价
  - 手动输入运费：7000 元
  - 验证保存成功

- [ ] **新增运单 - 自动模式**
  - 输入单价：350 元/吨
  - 输入装货：20 吨，卸货：19.8 吨
  - 验证运费自动计算：6930 元
  - 验证保存成功

- [ ] **编辑旧运单**
  - 打开旧运单编辑
  - 验证单价为空（手动模式）
  - 验证运费显示正确
  - 不修改任何内容，保存
  - 验证数据不变

- [ ] **编辑旧运单 - 添加单价**
  - 打开旧运单编辑
  - 输入单价：350 元/吨
  - 验证切换到自动模式
  - 验证运费重新计算
  - 保存并验证

### 项目配置测试

- [ ] **min_value 配置**
  - 项目配置：取较小值
  - 装货 20 吨，卸货 19.8 吨
  - 验证有效数量 = 19.8 吨

- [ ] **loading 配置**
  - 项目配置：取装货数量
  - 装货 20 吨，卸货 19.8 吨
  - 验证有效数量 = 20 吨

- [ ] **unloading 配置**
  - 项目配置：取卸货数量
  - 装货 20 吨，卸货 19.8 吨
  - 验证有效数量 = 19.8 吨

### 边界情况测试

- [ ] **只有装货重量**
  - 装货 20 吨，卸货为空
  - 验证有效数量计算

- [ ] **只有卸货重量**
  - 装货为空，卸货 19.8 吨
  - 验证有效数量计算

- [ ] **两个重量都为空**
  - 装货为空，卸货为空
  - 验证有效数量 = 0

- [ ] **单价为 0**
  - 单价 = 0
  - 验证切换到手动模式

- [ ] **切换项目**
  - 选择项目 A（配置：min_value）
  - 输入数据，验证计算
  - 切换到项目 B（配置：loading）
  - 验证有效数量重新计算

### 合作方成本测试

- [ ] **自动模式下的成本重算**
  - 创建运单（auto 模式）
  - 验证合作方成本正确
  
- [ ] **修改单价后的成本重算**
  - 修改单价
  - 验证运费重新计算
  - 验证合作方成本重新计算

---

## ✅ 总结

### 实现的功能

1. ✅ 前端单价输入和自动计算
2. ✅ 智能模式切换（有单价→auto，无单价→manual）
3. ✅ 项目配置驱动的有效数量计算
4. ✅ 数据库触发器自动计算
5. ✅ RPC 函数支持单价参数
6. ✅ 完全向后兼容

### 技术亮点

- **前后端双重计算**：前端实时预览，后端触发器保证数据一致性
- **项目配置驱动**：复用现有的 `effective_quantity_type` 配置
- **智能模式切换**：根据是否有单价自动判断
- **向后兼容**：旧数据完全不受影响

### 用户价值

- **提高效率**：减少手动计算错误
- **灵活性**：支持手动和自动两种模式
- **透明化**：清楚显示计算过程
- **可配置**：不同项目使用不同的有效数量计算方式

---

## 🚀 下一步

1. **执行数据库迁移文件**
2. **刷新前端页面**
3. **进行功能测试**
4. **用户培训**（如何使用单价功能）

---

**实施完成日期**：2025-11-20  
**文档版本**：1.0

