# 地点名称同步触发器说明

## 📋 概述

当地点名称（`locations.name`）修改时，自动同步更新所有相关运单的装货地点和卸货地点。

## 🔍 触发逻辑详解

### 1. 触发时机

- **触发表**：`locations` 表
- **触发条件**：`name` 字段更新
- **触发类型**：`AFTER UPDATE`
- **触发函数**：`sync_location_name_to_records()`

### 2. 如何找到原来的地址？

触发器使用 **`OLD.name`**（旧名称）来查找所有使用该名称的运单记录：

```sql
-- 查找装货地点
WHERE loading_location = OLD.name

-- 查找卸货地点
WHERE unloading_location = OLD.name
```

**工作原理**：
1. 当 `locations` 表的 `name` 字段从 `"北京"` 更新为 `"北京市"` 时
2. 触发器自动获取：
   - `OLD.name = "北京"`（旧名称）
   - `NEW.name = "北京市"`（新名称）
3. 在 `logistics_records` 表中查找：
   - `TRIM(loading_location) = TRIM("北京")` 的所有运单（**完全精确匹配**）
   - `TRIM(unloading_location) = TRIM("北京")` 的所有运单（**完全精确匹配**）
4. 将找到的运单的地点名称更新为 `TRIM("北京市")`（去除空格）

**完全匹配说明**：
- ✅ 使用 `=` 操作符：必须完全相等，不能多也不能少
- ✅ 使用 `TRIM()` 处理：去除前后空格后比较，确保精确匹配
- ✅ 不会误匹配：只有完全相同的名称才会被更新

### 3. 数据匹配方式

系统使用两种方式存储地点信息：

#### 方式1：文本字段（用于匹配）
- `logistics_records.loading_location`（文本）
- `logistics_records.unloading_location`（文本）

#### 方式2：ID数组（用于关联）
- `logistics_records.loading_location_ids`（UUID数组）
- `logistics_records.unloading_location_ids`（UUID数组）

**触发器匹配逻辑**：
- ✅ 通过 **文本字段**（`loading_location` / `unloading_location`）匹配
- ✅ 使用 `OLD.name` 查找所有使用旧名称的运单
- ✅ 更新为 `NEW.name`

**为什么通过文本字段匹配？**
- 因为地点ID（`locations.id`）不会改变，只有名称改变
- 运单表中存储的是地点名称的文本副本
- 通过名称匹配可以找到所有需要更新的运单

### 4. 执行流程

```
1. 用户修改 locations.name
   ↓
2. 触发器自动执行
   ↓
3. 获取 OLD.name（旧名称）和 NEW.name（新名称）
   ↓
4. 查找所有 loading_location = OLD.name 的运单
   ↓
5. 更新这些运单的 loading_location = NEW.name
   ↓
6. 查找所有 unloading_location = OLD.name 的运单
   ↓
7. 更新这些运单的 unloading_location = NEW.name
   ↓
8. 完成同步
```

## 📊 示例

### 场景：修改地点名称

**修改前**：
- `locations` 表：`id = 'abc-123'`, `name = '北京'`
- `logistics_records` 表：
  - 运单1：`loading_location = '北京'`
  - 运单2：`unloading_location = '北京'`

**执行操作**：
```sql
UPDATE locations SET name = '北京市' WHERE id = 'abc-123';
```

**触发器自动执行**：
1. 获取 `OLD.name = '北京'`, `NEW.name = '北京市'`
2. 查找 `loading_location = '北京'` 的运单 → 找到运单1
3. 更新运单1：`loading_location = '北京市'`
4. 查找 `unloading_location = '北京'` 的运单 → 找到运单2
5. 更新运单2：`unloading_location = '北京市'`

**修改后**：
- `locations` 表：`id = 'abc-123'`, `name = '北京市'`
- `logistics_records` 表：
  - 运单1：`loading_location = '北京市'` ✅
  - 运单2：`unloading_location = '北京市'` ✅

## ⚠️ 注意事项

1. **只更新名称字段**：触发器只更新 `loading_location` 和 `unloading_location` 文本字段
2. **不更新ID数组**：`loading_location_ids` 和 `unloading_location_ids` 不会改变（因为地点ID没变）
3. **批量更新**：一次地点名称修改会更新所有相关运单
4. **自动执行**：无需手动操作，修改地点名称后自动同步

## 🔧 相关函数

### 触发器函数
- `sync_location_name_to_records()` - 自动同步地点名称

### 手动修复函数
- `fix_inconsistent_location_names()` - 修复历史数据中不一致的地点名称

## 📝 日志输出

触发器会输出详细的日志信息：

```
========================================
地点名称变更触发同步
  地点ID: abc-123
  旧名称: "北京"
  新名称: "北京市"
========================================
✅ 已同步更新 5 条运单记录的装货地点（从 "北京" 更新为 "北京市"）
✅ 已同步更新 3 条运单记录的卸货地点（从 "北京" 更新为 "北京市"）
========================================
同步完成：装货地点 5 条，卸货地点 3 条
========================================
```

## ✅ 优势

1. **自动化**：无需手动更新，修改地点名称后自动同步
2. **准确性**：通过 `OLD.name` 精确匹配，不会误更新其他地点
3. **完整性**：同时更新装货地点和卸货地点
4. **可追溯**：详细的日志记录，方便排查问题

