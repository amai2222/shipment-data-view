# 成本重算函数代码重复问题分析

## ⚠️ 您的发现完全正确！

系统中**不是使用同一个函数**，而是**相同的计算逻辑重复了3次**！

---

## 📊 成本重算函数全览

### 函数清单（6个）

| 序号 | 函数名 | 功能 | 核心计算逻辑 | 代码重复 |
|-----|--------|------|------------|---------|
| 1 | `recalculate_costs_for_chain` | 重算指定链路所有运单 | ✅ 有 | 原始版本 |
| 2 | `recalculate_costs_for_chain_safe` | 安全重算链路（跳过已付款） | ✅ 有 | ❌ 重复 |
| 3 | `modify_logistics_record_chain_with_recalc` | 修改单个运单链路 | ✅ 有 | ❌ 重复 |
| 4 | `batch_modify_chain` | 批量修改链路 | ❌ 无（调用函数3） | 复用函数3 |
| 5 | `recalculate_costs_for_project` | 重算整个项目 | ❌ 无（调用函数1） | 复用函数1 |
| 6 | `auto_recalc_on_project_partner_change` | 触发器函数 | ❌ 无（调用函数1） | 复用函数1 |

---

## 🔍 重复代码详情

### 核心计算逻辑（约30行代码）

这段代码在**3个函数中完全重复**：

```sql
-- 🔴 重复代码段（出现在3个函数中）
-- ============================================

-- 计算应付金额
IF v_project_partners.calculation_method = 'profit' THEN
    -- 利润法
    IF v_loading_weight IS NOT NULL AND v_loading_weight > 0 THEN
        v_payable_amount := v_base_amount + (COALESCE(v_project_partners.profit_rate, 0) * v_loading_weight);
    ELSE
        v_payable_amount := v_base_amount + COALESCE(v_project_partners.profit_rate, 0);
    END IF;
ELSE
    -- 税点法（默认）
    IF v_project_partners.tax_rate IS NOT NULL AND v_project_partners.tax_rate != 1 THEN
        v_payable_amount := v_base_amount / (1 - v_project_partners.tax_rate);
    ELSE
        v_payable_amount := v_base_amount;
    END IF;
END IF;

-- 插入新的成本记录
INSERT INTO logistics_partner_costs (
    logistics_record_id,
    partner_id,
    level,
    base_amount,
    payable_amount,
    tax_rate,
    user_id
) VALUES (
    v_record_id,
    v_project_partners.partner_id,
    v_project_partners.level,
    v_base_amount,
    v_payable_amount,
    v_project_partners.tax_rate,
    auth.uid()
);
```

### 重复位置

| 函数 | 文件 | 行数范围 |
|-----|------|---------|
| `recalculate_costs_for_chain` | 20250122_auto_recalc_on_project_partner_change.sql | 68-102 |
| `recalculate_costs_for_chain_safe` | 20250122_auto_recalc_on_project_partner_change.sql | ~280-320 |
| `modify_logistics_record_chain_with_recalc` | 20251025_fix_modify_chain_with_recalculation.sql | 156-189 |

---

## 📈 函数调用关系图

```
用户操作触发
    │
    ├─> 修改项目合作方配置
    │   └─> auto_recalc_on_project_partner_change (触发器)
    │       └─> recalculate_costs_for_chain
    │           └─> [计算逻辑A] ← 第1次重复
    │
    ├─> 修改单个运单链路
    │   └─> modify_logistics_record_chain_with_recalc
    │       └─> [计算逻辑C] ← 第3次重复（与A相同）
    │
    ├─> 批量修改运单链路
    │   └─> batch_modify_chain
    │       └─> 循环调用 modify_logistics_record_chain_with_recalc
    │           └─> [计算逻辑C]
    │
    └─> 安全重算链路
        └─> recalculate_costs_for_chain_safe
            └─> [计算逻辑B] ← 第2次重复（与A相同）
```

---

## ⚠️ 风险分析

### 当前存在的风险

#### 1. 逻辑不一致风险 🔴 高危

**问题**：如果有人只修改了一个函数的计算逻辑，忘记修改其他函数

**后果**：
- 不同入口计算的成本不一致
- 数据混乱
- 难以排查

#### 2. 维护成本高 🟡 中危

**问题**：每次修改计算公式需要改3个地方

**后果**：
- 容易遗漏
- 增加开发时间
- 增加测试工作量

#### 3. 新增计算方法困难 🟡 中危

**问题**：如果要添加新的计算方法（如阶梯税点），需要修改3个地方

**示例**：
```sql
-- 假设要新增"阶梯税点法"
-- 需要在3个函数中都添加相同的逻辑
ELSIF v_project_partners.calculation_method = 'tiered_tax' THEN
    -- 阶梯计算逻辑
    ...
```

---

## 💡 解决方案

### 方案A：提取核心函数（推荐）✨

#### 步骤1：创建核心计算函数

```sql
-- ============================================================================
-- 核心：计算单个合作方的应付金额
-- ============================================================================
CREATE OR REPLACE FUNCTION public.calculate_partner_payable_amount(
    p_base_amount NUMERIC,
    p_loading_weight NUMERIC,
    p_calculation_method TEXT,
    p_tax_rate NUMERIC,
    p_profit_rate NUMERIC
)
RETURNS NUMERIC AS $$
DECLARE
    v_payable_amount NUMERIC;
BEGIN
    IF p_calculation_method = 'profit' THEN
        -- 利润法
        IF p_loading_weight IS NOT NULL AND p_loading_weight > 0 THEN
            v_payable_amount := p_base_amount + (COALESCE(p_profit_rate, 0) * p_loading_weight);
        ELSE
            v_payable_amount := p_base_amount + COALESCE(p_profit_rate, 0);
        END IF;
    ELSE
        -- 税点法（默认）
        IF p_tax_rate IS NOT NULL AND p_tax_rate != 1 THEN
            v_payable_amount := p_base_amount / (1 - p_tax_rate);
        ELSE
            v_payable_amount := p_base_amount;
        END IF;
    END IF;
    
    RETURN v_payable_amount;
END;
$$ LANGUAGE plpgsql IMMUTABLE SECURITY DEFINER;

COMMENT ON FUNCTION public.calculate_partner_payable_amount IS '计算合作方应付金额的核心函数';
```

#### 步骤2：修改所有重算函数调用核心函数

```sql
-- 在 recalculate_costs_for_chain 中
v_payable_amount := calculate_partner_payable_amount(
    v_base_amount,
    v_loading_weight,
    v_project_partners.calculation_method,
    v_project_partners.tax_rate,
    v_project_partners.profit_rate
);

-- 在 recalculate_costs_for_chain_safe 中
v_payable_amount := calculate_partner_payable_amount(
    v_base_amount,
    v_loading_weight,
    v_project_partners.calculation_method,
    v_project_partners.tax_rate,
    v_project_partners.profit_rate
);

-- 在 modify_logistics_record_chain_with_recalc 中
v_payable_amount := calculate_partner_payable_amount(
    v_base_amount,
    v_loading_weight,
    v_project_partners.calculation_method,
    v_project_partners.tax_rate,
    v_project_partners.profit_rate
);
```

**优点**：
- ✅ 只需维护一处计算逻辑
- ✅ 新增计算方法只需修改核心函数
- ✅ 保证所有函数计算一致
- ✅ 代码更清晰

---

### 方案B：文档化同步修改（次选）

如果不重构，至少要：

1. **创建修改清单**
   ```
   修改计算逻辑时必须同步修改：
   - recalculate_costs_for_chain (第68-83行)
   - recalculate_costs_for_chain_safe (第xxx行)
   - modify_logistics_record_chain_with_recalc (第156-170行)
   ```

2. **添加代码注释**
   ```sql
   -- ⚠️ 注意：此计算逻辑在以下函数中也存在
   -- - recalculate_costs_for_chain
   -- - recalculate_costs_for_chain_safe
   -- - modify_logistics_record_chain_with_recalc
   -- 修改时必须同步更新所有函数！
   ```

3. **创建验证脚本**
   ```sql
   -- 验证所有函数的计算结果是否一致
   SELECT verify_all_recalc_functions();
   ```

---

## 🎯 建议执行计划

### 短期（立即）

**保持现状 + 文档化**

1. ✅ 创建"成本重算函数同步修改清单.md"
2. ✅ 在代码中添加警告注释
3. ✅ 测试验证当前逻辑一致性

**原因**：
- 功能已在生产环境运行
- 重构有风险
- 需要完整测试

### 中期（1-2周后）

**重构为核心函数**

1. 创建 `calculate_partner_payable_amount` 核心函数
2. 逐步修改现有函数
3. 完整测试对比结果
4. 部署到生产环境

**原因**：
- 降低长期维护成本
- 减少出错可能
- 便于扩展新功能

---

## 📋 成本计算逻辑说明

### 利润法（Profit Method）

```
应付金额 = 基础金额 + (利润率 × 装货重量)

示例：
- 基础金额：1000元
- 利润率：50元/吨
- 装货重量：10吨
- 应付金额 = 1000 + (50 × 10) = 1500元
```

### 税点法（Tax Method）

```
应付金额 = 基础金额 / (1 - 税率)

示例：
- 基础金额：1000元
- 税率：0.06 (6%)
- 应付金额 = 1000 / (1 - 0.06) = 1063.83元
```

---

## 🧪 一致性验证

### 验证脚本

```sql
-- 创建测试运单
INSERT INTO logistics_records (id, ...) VALUES (...);

-- 使用3个不同函数重算
SELECT recalculate_costs_for_chain(...);
SELECT recalculate_costs_for_chain_safe(...);
SELECT modify_logistics_record_chain_with_recalc(...);

-- 对比结果是否一致
SELECT 
    lr.auto_number,
    lpc1.payable_amount as amount_from_func1,
    lpc2.payable_amount as amount_from_func2,
    lpc3.payable_amount as amount_from_func3,
    CASE 
        WHEN lpc1.payable_amount = lpc2.payable_amount 
         AND lpc2.payable_amount = lpc3.payable_amount 
        THEN '✅ 一致'
        ELSE '❌ 不一致'
    END as check_result
FROM ...;
```

---

## 📝 修改历史追踪

### 这些函数是何时创建的？

| 函数 | 创建日期 | 迁移文件 |
|-----|---------|---------|
| `recalculate_costs_for_chain` | 2025-01-22 | 20250122_auto_recalc_on_project_partner_change.sql |
| `recalculate_costs_for_chain_safe` | 2025-01-22 | 20250122_auto_recalc_on_project_partner_change.sql |
| `recalculate_costs_for_project` | 2025-01-22 | 20250122_auto_recalc_on_project_partner_change.sql |
| `modify_logistics_record_chain_with_recalc` | 2025-10-25 | 20251025_fix_modify_chain_with_recalculation.sql |
| `batch_modify_chain` | 2025-10-25 | 20251025_add_batch_modify_functions.sql |

**分析**：
- 函数1-3在同一天创建（2025-01-22）
- 函数4在3个月后创建（2025-10-25）
- 创建函数4时**复制粘贴**了计算逻辑，没有复用

---

## ⚠️ 实际问题案例

### 如果要修改计算公式

**场景**：税点法改为 `base_amount / (1 + tax_rate)` （税前价）

**需要修改的地方**：

1. ✅ `recalculate_costs_for_chain` (第78-82行)
   ```sql
   v_payable_amount := v_base_amount / (1 + v_project_partners.tax_rate);
   ```

2. ✅ `recalculate_costs_for_chain_safe` (相应行)
   ```sql
   v_payable_amount := v_base_amount / (1 + v_project_partners.tax_rate);
   ```

3. ✅ `modify_logistics_record_chain_with_recalc` (第165-169行)
   ```sql
   v_payable_amount := v_base_amount / (1 + v_project_partners.tax_rate);
   ```

**如果遗漏一处**：
- ❌ 不同入口计算结果不一致
- ❌ 数据混乱
- ❌ 难以排查

---

## 💡 重构方案详解

### 创建核心计算函数

```sql
-- ============================================================================
-- 核心函数：计算合作方应付金额
-- ============================================================================
-- 功能：根据计算方法（利润法/税点法）计算应付金额
-- 参数：
--   p_base_amount      - 基础金额（current_cost + extra_cost）
--   p_loading_weight   - 装货重量
--   p_calculation_method - 计算方法（'profit' 或 'tax'）
--   p_tax_rate         - 税率（0-1之间的小数）
--   p_profit_rate      - 利润率（元/吨 或 固定金额）
-- 返回：应付金额
-- ============================================================================
CREATE OR REPLACE FUNCTION public.calculate_partner_payable_amount(
    p_base_amount NUMERIC,
    p_loading_weight NUMERIC,
    p_calculation_method TEXT,
    p_tax_rate NUMERIC,
    p_profit_rate NUMERIC
)
RETURNS NUMERIC AS $$
DECLARE
    v_payable_amount NUMERIC;
BEGIN
    -- 参数验证
    IF p_base_amount IS NULL OR p_base_amount < 0 THEN
        RAISE EXCEPTION '基础金额不能为空或负数';
    END IF;
    
    -- 根据计算方法计算
    IF p_calculation_method = 'profit' THEN
        -- ========== 利润法 ==========
        IF p_loading_weight IS NOT NULL AND p_loading_weight > 0 THEN
            -- 利润率 × 重量
            v_payable_amount := p_base_amount + (COALESCE(p_profit_rate, 0) * p_loading_weight);
        ELSE
            -- 固定利润
            v_payable_amount := p_base_amount + COALESCE(p_profit_rate, 0);
        END IF;
    ELSE
        -- ========== 税点法（默认） ==========
        IF p_tax_rate IS NOT NULL AND p_tax_rate != 0 AND p_tax_rate != 1 THEN
            -- 含税价 = 税前价 / (1 - 税率)
            v_payable_amount := p_base_amount / (1 - p_tax_rate);
        ELSE
            -- 无税或税率为0
            v_payable_amount := p_base_amount;
        END IF;
    END IF;
    
    RETURN ROUND(v_payable_amount, 2);  -- 保留2位小数
END;
$$ LANGUAGE plpgsql IMMUTABLE SECURITY DEFINER;

COMMENT ON FUNCTION public.calculate_partner_payable_amount IS 
'计算合作方应付金额的核心函数（利润法/税点法）';
```

### 修改后的重算函数示例

```sql
-- 修改 recalculate_costs_for_chain
FOR v_project_partners IN ... LOOP
    -- 🎯 调用核心函数，不再重复代码
    v_payable_amount := calculate_partner_payable_amount(
        v_base_amount,
        v_loading_weight,
        v_project_partners.calculation_method,
        v_project_partners.tax_rate,
        v_project_partners.profit_rate
    );
    
    INSERT INTO logistics_partner_costs (...) VALUES (...);
END LOOP;
```

---

## 📊 重构前后对比

| 指标 | 重构前 | 重构后 |
|-----|--------|--------|
| **代码重复** | 3次 | 0次 |
| **维护点** | 3个函数 | 1个核心函数 |
| **修改计算逻辑** | 改3处 | 改1处 |
| **新增计算方法** | 改3处 | 改1处 |
| **出错风险** | 高 | 低 |
| **代码行数** | ~90行（重复） | ~30行（核心）|

---

## 🎯 重构优先级

### 紧急程度：🟡 中等

**原因**：
- 当前功能正常
- 但存在长期风险
- 建议尽快重构

### 影响范围：🟢 可控

**重构影响**：
- 只涉及成本计算逻辑
- 接口不变
- 可以逐步迁移

### 建议时间：📅 1-2周内

**理由**：
- 避免积累更多技术债
- 趁记忆犹新时重构
- 降低未来维护成本

---

## 📝 同步修改清单（如果不重构）

### ⚠️ 修改计算逻辑时必须同步

| 序号 | 函数名 | 文件 | 行数 |
|-----|--------|------|------|
| 1 | `recalculate_costs_for_chain` | 20250122_auto_recalc_on_project_partner_change.sql | 68-83 |
| 2 | `recalculate_costs_for_chain_safe` | 20250122_auto_recalc_on_project_partner_change.sql | ~280-320 |
| 3 | `modify_logistics_record_chain_with_recalc` | 20251025_fix_modify_chain_with_recalculation.sql | 156-170 |

### 验证步骤

1. 对比3个函数的计算逻辑代码
2. 确保完全一致（逐行对比）
3. 测试相同输入得到相同结果
4. 在代码中添加同步修改提醒注释

---

## 🚀 下一步行动

### 选项A：立即重构（推荐）

**优点**：一劳永逸  
**时间**：2-3小时  
**风险**：需要测试

### 选项B：暂不重构

**优点**：零风险  
**缺点**：长期维护成本高  
**要求**：必须严格同步修改

---

**您希望我创建重构方案吗？还是先添加同步修改的警告注释？** 🤔

