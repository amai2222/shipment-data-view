# 合作方名称修改同步问题分析

## 🎯 问题

**用户疑问**：如果在合作方管理中修改合作方名称，是否需要同步更新到所有相关表？

## 📊 数据库结构分析

### 1. 主表：partners（合作方表）

```sql
CREATE TABLE public.partners (
    id uuid PRIMARY KEY,
    name text NOT NULL,           -- ⭐ 合作方名称
    full_name text,                -- 全称
    tax_number text,
    company_address text,
    tax_rate numeric(5,4) NOT NULL,
    partner_type partner_type_enum,
    parent_partner_id uuid,        -- 上级合作方
    hierarchy_path text,
    created_at timestamp,
    updated_at timestamp
);
```

### 2. 关联表分析

#### ✅ 只存储外键的表（不需要同步）

**2.1 project_partners（项目合作方关联表）**

```sql
CREATE TABLE public.project_partners (
    id uuid PRIMARY KEY,
    project_id uuid NOT NULL,
    chain_id uuid NOT NULL,
    partner_id uuid NOT NULL,      -- ✅ 只有外键，没有 partner_name
    level integer NOT NULL,
    calculation_method text,
    tax_rate numeric(5,4),
    profit_rate numeric(12,2),
    FOREIGN KEY (partner_id) REFERENCES partners(id) ON DELETE CASCADE
);
```

**查询时使用 JOIN**：
```sql
SELECT 
    pp.*,
    p.name as partner_name,        -- ✅ 从主表实时获取
    p.full_name as partner_full_name
FROM project_partners pp
JOIN partners p ON pp.partner_id = p.id;
```

**结论**：✅ **不需要同步**，查询时自动获取最新名称。

---

**2.2 logistics_partner_costs（运单合作方成本表）**

```sql
CREATE TABLE public.logistics_partner_costs (
    id uuid PRIMARY KEY,
    logistics_record_id uuid NOT NULL,
    partner_id uuid NOT NULL,      -- ✅ 只有外键，没有 partner_name
    level integer NOT NULL,
    base_amount numeric(12,2),
    payable_amount numeric(12,2),
    tax_rate numeric(5,4),
    payment_status text,
    invoice_status text,
    FOREIGN KEY (partner_id) REFERENCES partners(id) ON DELETE CASCADE
);
```

**查询时使用 JOIN**：
```sql
SELECT 
    lpc.*,
    p.name as partner_name,        -- ✅ 从主表实时获取
    p.full_name as partner_full_name
FROM logistics_partner_costs lpc
JOIN partners p ON lpc.partner_id = p.id;
```

**结论**：✅ **不需要同步**，查询时自动获取最新名称。

---

#### ⚠️ 有冗余存储的表（需要评估）

**2.3 invoice_requests（开票申请表）**

```sql
CREATE TABLE public.invoice_requests (
    id uuid PRIMARY KEY,
    request_number text NOT NULL,
    partner_id uuid,                      -- 外键
    partner_name text NOT NULL,           -- ⚠️ 冗余字段！
    partner_full_name text,               -- ⚠️ 冗余字段！
    tax_number text,                      -- ⚠️ 冗余字段！
    company_address text,                 -- ⚠️ 冗余字段！
    bank_name text,                       -- ⚠️ 冗余字段！
    bank_account text,                    -- ⚠️ 冗余字段！
    status text DEFAULT 'Pending',
    applied_at timestamp,
    approved_at timestamp,
    invoice_date date,
    invoice_number text,
    is_voided boolean DEFAULT false,
    FOREIGN KEY (partner_id) REFERENCES partners(id)
);
```

**为什么有冗余**？  
开票申请是**历史快照**，需要记录申请时的合作方信息，即使以后合作方信息改了，历史记录也应该保持不变。

**结论**：⚠️ **不应该同步**（保持历史准确性）

---

**2.4 logistics_records（运单记录表）**

```sql
CREATE TABLE public.logistics_records (
    id uuid PRIMARY KEY,
    auto_number text NOT NULL,
    project_id uuid,
    project_name text NOT NULL,           -- ⚠️ 冗余：项目名称
    driver_id uuid,
    driver_name text NOT NULL,            -- ⚠️ 冗余：司机名称
    driver_phone text NOT NULL,           -- ⚠️ 冗余：司机电话
    license_plate text NOT NULL,          -- ⚠️ 冗余：车牌号
    chain_id uuid,
    -- 注意：没有 partner_name（合作方通过 logistics_partner_costs 关联）
    FOREIGN KEY (project_id) REFERENCES projects(id),
    FOREIGN KEY (driver_id) REFERENCES drivers(id),
    FOREIGN KEY (chain_id) REFERENCES partner_chains(id)
);
```

**结论**：✅ 运单表**没有直接存储** `partner_name`（合作方信息在 `logistics_partner_costs` 表中）

---

## 📋 数据同步策略

### 方案1：保持现状（推荐）⭐⭐⭐

**策略**：
- ✅ 修改 `partners.name` 后，**不同步**到其他表
- ✅ 查询时通过 JOIN 获取最新名称
- ✅ 历史记录（如已开票的申请）保持原样

**优点**：
1. 数据一致性好（单一数据源）
2. 避免历史数据被篡改
3. 维护简单
4. 符合数据库规范化原则

**缺点**：
1. 查询需要 JOIN（性能略低）
2. 已开票记录显示的是快照信息（可能与当前名称不一致）

**代码示例**：
```typescript
// 前端查询时自动 JOIN
const { data } = await supabase
  .from('project_partners')
  .select(`
    *,
    partners (
      name,
      full_name
    )
  `);
```

---

### 方案2：选择性同步（不推荐）⚠️

**策略**：
- 修改 `partners.name` 时，同步更新 **待处理** 的开票申请
- **已完成** 的开票申请不更新（保持历史）

**实现**：
```sql
-- 创建触发器：合作方名称修改时同步
CREATE OR REPLACE FUNCTION sync_partner_name_change()
RETURNS TRIGGER AS $$
BEGIN
    -- 只更新待处理的开票申请
    UPDATE invoice_requests
    SET 
        partner_name = NEW.name,
        partner_full_name = NEW.full_name,
        updated_at = NOW()
    WHERE partner_id = NEW.id
      AND status IN ('Pending', 'Draft')  -- 只更新待处理的
      AND is_voided = FALSE;
    
    RAISE NOTICE '已更新 % 条待处理开票申请的合作方名称', found;
    
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER trigger_sync_partner_name
    AFTER UPDATE OF name, full_name ON partners
    FOR EACH ROW
    WHEN (OLD.name IS DISTINCT FROM NEW.name OR 
          OLD.full_name IS DISTINCT FROM NEW.full_name)
    EXECUTE FUNCTION sync_partner_name_change();
```

**缺点**：
1. 增加系统复杂度
2. 可能导致数据不一致
3. 需要明确定义哪些记录需要同步

---

### 方案3：全量同步（强烈不推荐）❌

**策略**：
- 修改 `partners.name` 时，更新 **所有** 相关表的冗余字段

**问题**：
1. ❌ 破坏历史数据完整性
2. ❌ 已开票记录被修改（审计问题）
3. ❌ 性能问题（大量更新）
4. ❌ 可能违反财务合规要求

---

## 💡 推荐实施方案

### 当前系统（最优）✅

**保持现状，原因**：

1. **大部分表设计合理**：
   - `project_partners` ✅ 只存外键
   - `logistics_partner_costs` ✅ 只存外键
   - 查询时 JOIN 获取最新名称

2. **历史记录有冗余是正确的**：
   - `invoice_requests` 的冗余字段是**有意设计**
   - 保留申请时的快照信息
   - 符合财务审计要求

3. **修改合作方名称的影响**：
   ```
   修改 partners.name
       ↓
   project_partners 查询 → 显示新名称 ✅
   logistics_partner_costs 查询 → 显示新名称 ✅
   invoice_requests（已完成）→ 显示旧名称 ✅（应该保持）
   invoice_requests（待处理）→ 显示旧名称 ⚠️（可选择性更新）
   ```

### 可选优化（如果需要）

**问题场景**：  
用户修改了合作方名称，但**待处理**的开票申请仍显示旧名称。

**优化方案**：

#### 选项A：前端显示时动态获取

```typescript
// 前端查询开票申请时
const { data: invoiceRequests } = await supabase
  .from('invoice_requests')
  .select(`
    *,
    partners!invoice_requests_partner_id_fkey (
      name,
      full_name
    )
  `);

// 显示时优先使用最新名称
const displayName = invoiceRequest.partners?.name || invoiceRequest.partner_name;
```

**优点**：
- ✅ 显示最新名称
- ✅ 数据库不需要修改
- ✅ 历史记录仍然保留

---

#### 选项B：添加触发器（仅更新待处理记录）

```sql
-- 创建触发器（见方案2）
CREATE TRIGGER trigger_sync_partner_name_for_pending
    AFTER UPDATE OF name, full_name ON partners
    FOR EACH ROW
    EXECUTE FUNCTION sync_partner_name_to_pending_invoices();
```

**优点**：
- ✅ 待处理记录自动更新
- ✅ 已完成记录保持不变

**缺点**：
- ⚠️ 增加系统复杂度
- ⚠️ 需要明确定义"待处理"的范围

---

## 🎯 最终建议

### 立即执行：保持现状 ✅

**当前设计已经很合理**：
1. 核心业务表（project_partners, logistics_partner_costs）使用外键
2. 历史快照表（invoice_requests）有冗余是正确的
3. 修改合作方名称会自动影响未来的查询

### 用户操作指南

**修改合作方名称后**：

1. **已经提交的开票申请** → 显示旧名称（✅ 正确，保持历史）
2. **新创建的开票申请** → 显示新名称（✅ 自动）
3. **项目配置页面** → 显示新名称（✅ 自动，通过 JOIN）
4. **运单成本记录** → 显示新名称（✅ 自动，通过 JOIN）

### 如果需要强制更新待处理申请

**执行 SQL（一次性）**：
```sql
-- 手动更新待处理的开票申请（如果确实需要）
UPDATE invoice_requests ir
SET 
    partner_name = p.name,
    partner_full_name = p.full_name
FROM partners p
WHERE ir.partner_id = p.id
  AND ir.status IN ('Pending', 'Draft')
  AND ir.is_voided = FALSE;
```

---

## 📊 数据流图

```
合作方管理
    ↓
  修改 partners.name = "新名称"
    ↓
┌─────────────────────────────────────────┐
│                                         │
│  通过外键关联的表（自动显示新名称）     │
│  ├─ project_partners                    │
│  │   └─ JOIN partners → 显示新名称 ✅   │
│  │                                      │
│  ├─ logistics_partner_costs             │
│  │   └─ JOIN partners → 显示新名称 ✅   │
│  │                                      │
│  └─ 前端查询时自动 JOIN                 │
│                                         │
└─────────────────────────────────────────┘

┌─────────────────────────────────────────┐
│                                         │
│  冗余存储的表（显示快照名称）           │
│  └─ invoice_requests                    │
│      ├─ 已完成：显示旧名称（历史快照）✅ │
│      └─ 待处理：显示旧名称（可选更新）⚠️ │
│                                         │
└─────────────────────────────────────────┘
```

---

## ⚠️ 注意事项

1. **财务合规**：
   - 已开票、已付款的记录**不应该**修改
   - 保持历史数据的完整性和可追溯性

2. **审计要求**：
   - 历史记录应该显示当时的实际信息
   - 不应该因为后续修改而改变

3. **用户体验**：
   - 可以在界面上同时显示"当前名称"和"申请时名称"
   - 例如：`当前名称（申请时：旧名称）`

---

## 📅 总结

### 问题答案

**Q：修改合作方名称后，是否需要同步到所有表？**

**A：不需要！** ✅

**原因**：
1. 核心业务表通过外键关联，查询时自动获取最新名称
2. 历史快照表（如开票申请）的冗余字段是有意设计，应该保持不变
3. 当前设计符合数据库规范化和财务审计要求

**特殊情况**：
- 如果确实需要更新待处理的开票申请，可以手动执行 SQL 或添加触发器
- 但已完成的记录**绝对不应该**修改

---

**当前设计是正确的，不需要额外的同步机制！** ✅

